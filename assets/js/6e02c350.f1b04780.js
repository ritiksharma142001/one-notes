"use strict";(globalThis.webpackChunkes_note=globalThis.webpackChunkes_note||[]).push([[5631],{28453(e,n,i){i.d(n,{R:()=>s,x:()=>d});var l=i(96540);const t={},o=l.createContext(t);function s(e){const n=l.useContext(o);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),l.createElement(o.Provider,{value:n},e.children)}},85752(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>r});const l=JSON.parse('{"id":"advanced-java/0-1/Week-2/2.5","title":"PUT, PATCH and DELETE Mappings","description":"Additional Mappings and Code Optimization","source":"@site/docs/advanced-java/0-1/Week-2/2.5.md","sourceDirName":"advanced-java/0-1/Week-2","slug":"/advanced-java/0-1/Week-2/2.5","permalink":"/one-notes/advanced-java/0-1/Week-2/2.5","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/advanced-java/0-1/Week-2/2.5.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Service Layer","permalink":"/one-notes/advanced-java/0-1/Week-2/2.4"},"next":{"title":"Input Validation","permalink":"/one-notes/advanced-java/0-1/Week-2/2.6"}}');var t=i(74848),o=i(28453);const s={sidebar_position:5},d="PUT, PATCH and DELETE Mappings",a={},r=[{value:"Additional Mappings and Code Optimization",id:"additional-mappings-and-code-optimization",level:2},{value:"Implement the remaining HTTP methods:",id:"implement-the-remaining-http-methods",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Implementing PUT Mapping for Employee Update by ID",id:"implementing-put-mapping-for-employee-update-by-id",level:3},{value:"Setting Up the PUT Mapping",id:"setting-up-the-put-mapping",level:3},{value:"Receiving Data for Update",id:"receiving-data-for-update",level:3},{value:"Calling the Service Method",id:"calling-the-service-method",level:3},{value:"Handling the Update Logic in Service Layer",id:"handling-the-update-logic-in-service-layer",level:3},{value:"Behavior Based on Employee Presence",id:"behavior-based-on-employee-presence",level:3},{value:"Explanation with HashMap Analogy",id:"explanation-with-hashmap-analogy",level:3},{value:"Returning the Response",id:"returning-the-response",level:3},{value:"Delete Employee by ID \u2013 Explanation Summary",id:"delete-employee-by-id--explanation-summary",level:2},{value:"Delete Mapping in REST API",id:"delete-mapping-in-rest-api",level:3},{value:"Method Signature",id:"method-signature",level:3},{value:"Deleting the Employee",id:"deleting-the-employee",level:3},{value:"Lack of Feedback",id:"lack-of-feedback",level:3},{value:"Improved Approach with Boolean Return",id:"improved-approach-with-boolean-return",level:3},{value:"esting the API",id:"esting-the-api",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"PATCH Mapping in Spring Boot: Partial Update of Employee Entity",id:"patch-mapping-in-spring-boot-partial-update-of-employee-entity",level:2},{value:"Why PATCH Mapping Is Needed",id:"why-patch-mapping-is-needed",level:3},{value:"Problem with PUT Mapping Example",id:"problem-with-put-mapping-example",level:3},{value:"Solution: Use @PatchMapping with Map Input",id:"solution-use-patchmapping-with-map-input",level:3},{value:"Handling Null Fields Safely",id:"handling-null-fields-safely",level:3},{value:"Service Method Outline",id:"service-method-outline",level:3},{value:"Reflection-Based Partial Update in Java (Spring Boot)",id:"reflection-based-partial-update-in-java-spring-boot",level:2},{value:"Entity Presence Check",id:"entity-presence-check",level:3},{value:"Error Handling (Optional)",id:"error-handling-optional",level:3},{value:"Updating Fields Dynamically",id:"updating-fields-dynamically",level:3},{value:"Use of Reflection",id:"use-of-reflection",level:3},{value:"Iterating Through Updates",id:"iterating-through-updates",level:3},{value:"Getting the Field Object",id:"getting-the-field-object",level:3},{value:"Making Field Accessible",id:"making-field-accessible",level:3},{value:"Setting Field Value",id:"setting-field-value",level:3},{value:"Saving the Updated Entity",id:"saving-the-updated-entity",level:3},{value:"Returning the Updated DTO",id:"returning-the-updated-dto",level:3},{value:"Why Reflection is Useful",id:"why-reflection-is-useful",level:3},{value:"Testing the PATCH Endpoint",id:"testing-the-patch-endpoint",level:3},{value:"code",id:"code",level:2},{value:"Fixes for isActive Field in JSON Serialization with Jackson",id:"fixes-for-isactive-field-in-json-serialization-with-jackson",level:2},{value:"Observation of PATCH Behavior:",id:"observation-of-patch-behavior",level:3},{value:"Issue with Boolean Field isActive:",id:"issue-with-boolean-field-isactive",level:3},{value:"Root Cause of the Issue:",id:"root-cause-of-the-issue",level:3},{value:"Fix with @JsonProperty:",id:"fix-with-jsonproperty",level:3},{value:"Consistency Required Across DTOs and Entities:",id:"consistency-required-across-dtos-and-entities",level:3},{value:"Handling Getters and Setters:",id:"handling-getters-and-setters",level:3},{value:"Solution with Lombok:",id:"solution-with-lombok",level:3},{value:"Final Result:",id:"final-result",level:3},{value:"Using ResponseEntity to Return Meaningful HTTP Status Codes",id:"using-responseentity-to-return-meaningful-http-status-codes",level:2},{value:"Purpose of ResponseEntity:",id:"purpose-of-responseentity",level:3},{value:"How to Use <code>ResponseEntity</code>:",id:"how-to-use-responseentity",level:3},{value:"Returning ResponseEntity for Get by ID:",id:"returning-responseentity-for-get-by-id",level:3},{value:"Handling Null Issues with ModelMapper:",id:"handling-null-issues-with-modelmapper",level:3},{value:"Mapping Optional Entity to DTO:",id:"mapping-optional-entity-to-dto",level:3},{value:"code",id:"code-1",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"put-patch-and-delete-mappings",children:"PUT, PATCH and DELETE Mappings"})}),"\n",(0,t.jsx)(n.h2,{id:"additional-mappings-and-code-optimization",children:"Additional Mappings and Code Optimization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We will now:"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implement-the-remaining-http-methods",children:"Implement the remaining HTTP methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"@PutMapping"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"@PatchMapping"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"@DeleteMapping"})}),"\n",(0,t.jsx)(n.li,{children:"Perform code optimizations to make the application more aligned with industry standards."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"@PutMapping"})," (Full Update)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Used when updating the entire resource."}),"\n",(0,t.jsxs)(n.li,{children:["Example: Changing all details of an employee with ID ",(0,t.jsx)(n.code,{children:"1"}),' from "Ram" to "Shyam" \u2014 the ID remains the same, but all other details are replaced.']}),"\n",(0,t.jsx)(n.li,{children:"Ideal when replacing the whole object on the backend."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"@PatchMapping"})," (Partial Update)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Used when updating specific fields of an existing resource."}),"\n",(0,t.jsx)(n.li,{children:"Example: Only updating the employee's name or department, not the entire employee record."}),"\n",(0,t.jsx)(n.li,{children:"Suitable for modifying only a subset of fields without affecting the rest."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementing-put-mapping-for-employee-update-by-id",children:"Implementing PUT Mapping for Employee Update by ID"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We aim to return an ",(0,t.jsx)(n.code,{children:"EmployeeDto"})," after updating an employee by their ID."]}),"\n",(0,t.jsxs)(n.li,{children:["The function name ",(0,t.jsx)(n.code,{children:"updateEmployeeById"})," is descriptive and follows good naming conventions."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"setting-up-the-put-mapping",children:"Setting Up the PUT Mapping"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We use ",(0,t.jsx)(n.code,{children:"@PutMapping"})," and append the ",(0,t.jsx)(n.code,{children:"employeeId"})," to the path."]}),"\n",(0,t.jsxs)(n.li,{children:["Example path: ",(0,t.jsx)(n.code,{children:"/api/employees/{employeeId}"})]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"employeeId"})," is extracted using ",(0,t.jsx)(n.code,{children:"@PathVariable"})," of type ",(0,t.jsx)(n.code,{children:"Long"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"receiving-data-for-update",children:"Receiving Data for Update"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The updated employee data is passed in the request body using ",(0,t.jsx)(n.code,{children:"@RequestBody"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The data is received as an ",(0,t.jsx)(n.code,{children:"EmployeeDto"})," object."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"calling-the-service-method",children:"Calling the Service Method"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We call a service method: ",(0,t.jsx)(n.code,{children:"updateEmployeeById(employeeId, employeeDto)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If not already defined, we create this method in the ",(0,t.jsx)(n.code,{children:"EmployeeService"})," class."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"handling-the-update-logic-in-service-layer",children:"Handling the Update Logic in Service Layer"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Inside the service method:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Convert EmployeeDto to ",(0,t.jsx)(n.code,{children:"EmployeeEntity"})," using ",(0,t.jsx)(n.code,{children:"ModelMapper"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Set the ",(0,t.jsx)(n.code,{children:"id"})," of the entity manually in case it's not present in the DTO."]}),"\n",(0,t.jsxs)(n.li,{children:["Save the entity using ",(0,t.jsx)(n.code,{children:"employeeRepository.save(employeeEntity)"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"behavior-based-on-employee-presence",children:"Behavior Based on Employee Presence"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the employee exists:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The record will be updated."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If the employee does not exist:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A new employee record will be created with the given ID and data."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"explanation-with-hashmap-analogy",children:"Explanation with HashMap Analogy"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Similar to how a ",(0,t.jsx)(n.code,{children:"HashMap"})," works:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the key (employee ID) exists, the value is updated."}),"\n",(0,t.jsx)(n.li,{children:"If the key doesn't exist, a new entry is created."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"returning-the-response",children:"Returning the Response"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Convert the saved entity back to ",(0,t.jsx)(n.code,{children:"EmployeeDto"})," using ModelMapper."]}),"\n",(0,t.jsx)(n.li,{children:"Return the DTO as the response to the client."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"delete-employee-by-id--explanation-summary",children:"Delete Employee by ID \u2013 Explanation Summary"}),"\n",(0,t.jsx)(n.h3,{id:"delete-mapping-in-rest-api",children:"Delete Mapping in REST API"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"To delete an employee, a @DeleteMapping is used."}),"\n",(0,t.jsxs)(n.li,{children:["The employee ID is passed as a path variable (e.g., ",(0,t.jsx)(n.code,{children:"/employee/{id}"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"No RequestBody is required since only the ID is sufficient."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"method-signature",children:"Method Signature"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Initially, a void method is used for deletion."}),"\n",(0,t.jsx)(n.li,{children:"Later, it is changed to return a boolean to indicate success or failure of the delete operation."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"deleting-the-employee",children:"Deleting the Employee"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"mployeeRepository.deleteById(id)"})," is called to remove the employee from the database."]}),"\n",(0,t.jsx)(n.li,{children:"If the employee exists, it is deleted successfully."}),"\n",(0,t.jsx)(n.li,{children:"If the employee does not exist, no action is taken and no error is shown."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"lack-of-feedback",children:"Lack of Feedback"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Initially, no response is returned to indicate whether the employee was found or deleted."}),"\n",(0,t.jsx)(n.li,{children:"This makes it unclear if the delete operation actually succeeded."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"improved-approach-with-boolean-return",children:"Improved Approach with Boolean Return"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The method return type is updated to boolean to provide better feedback."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"employeeRepository.existsById(id)"})," is used:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the employee exists, it is deleted and true is returned."}),"\n",(0,t.jsx)(n.li,{children:"If the employee does not exist, false is returned."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"esting-the-api",children:"esting the API"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Example:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Employee with ID 54 exists \u2192 delete returns true."}),"\n",(0,t.jsx)(n.li,{children:"Employee with ID 55 does not exist \u2192 delete returns false."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The final version provides a better user experience by indicating the result of the delete action."}),"\n",(0,t.jsxs)(n.li,{children:["The API now supports full CRUD operations:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Get all employees"}),"\n",(0,t.jsx)(n.li,{children:"Get employee by ID"}),"\n",(0,t.jsx)(n.li,{children:"Create employee"}),"\n",(0,t.jsx)(n.li,{children:"Update employee"}),"\n",(0,t.jsx)(n.li,{children:"Delete employee by ID (with feedback)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'    @PutMapping(path = "/{employeeId}")\n    public EmployeeDTO updateEmployeeById(@RequestBody EmployeeDTO employeeDTO, @PathVariable Long employeeId) {\n        return employeeService.updateEmployeeById(employeeId, employeeDTO);\n    }\n\n\n    @DeleteMapping(path= "/{employeeId}")\n    public boolean deleteEmployeeById(@PathVariable Long employeeId) {\n        return employeeService.deleteEmployeeById(employeeId);\n    }\n\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public EmployeeDTO updateEmployeeById(Long employeeId, EmployeeDTO employeeDTO) {\n        EmployeeEntity employeeEntity = modelMapper.map(employeeDTO, EmployeeEntity.class);\n        employeeEntity.setId(employeeId);\n        EmployeeEntity savedEmployeeEntity = employeeRepository.save(employeeEntity);\n        return modelMapper.map(savedEmployeeEntity, EmployeeDTO.class);\n    }\n\n    public boolean deleteEmployeeById(Long employeeId) {\n        boolean exists = employeeRepository.existsById(employeeId);\n        if(!exists) return false;\n        employeeRepository.deleteById(employeeId);\n        return true;\n    }\n"})}),"\n",(0,t.jsx)(n.h2,{id:"patch-mapping-in-spring-boot-partial-update-of-employee-entity",children:"PATCH Mapping in Spring Boot: Partial Update of Employee Entity"}),"\n",(0,t.jsx)(n.h3,{id:"why-patch-mapping-is-needed",children:"Why PATCH Mapping Is Needed"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Partial updates (e.g., updating only ",(0,t.jsx)(n.code,{children:"name"}),") using ",(0,t.jsx)(n.code,{children:"@PutMapping"})," may result in other fields being overwritten with nul`l."]}),"\n",(0,t.jsxs)(n.li,{children:["Using PUT with incomplete data causes the remaining fields (",(0,t.jsx)(n.code,{children:"email"}),", ",(0,t.jsx)(n.code,{children:"age"}),", ",(0,t.jsx)(n.code,{children:"dateOfJoining"}),", etc.) to be lost."]}),"\n",(0,t.jsx)(n.li,{children:"This is undesirable\u2014we only want to update specific fields without affecting the rest."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"problem-with-put-mapping-example",children:"Problem with PUT Mapping Example"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Suppose we update employee with ",(0,t.jsx)(n.code,{children:"`id=1`"}),"and send only:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "name": "XYZ"\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Result: Only ",(0,t.jsx)(n.code,{children:"name"})," is updated, but ",(0,t.jsx)(n.code,{children:"email"}),", ",(0,t.jsx)(n.code,{children:"age"}),", and ",(0,t.jsx)(n.code,{children:"dateOfJoining"})," become ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"solution-use-patchmapping-with-map-input",children:"Solution: Use @PatchMapping with Map Input"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Instead of sending the full entity, send a map containing only the fields to update"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@PatchMapping("/employees/{id}")\npublic EmployeeDTO updatePartialEmployeeById(\n    @PathVariable Long id,\n    @RequestBody Map<String, Object> updates\n)\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use a ",(0,t.jsx)(n.code,{children:"Map<String, Object>"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"key"})," = field name (e.g., ",(0,t.jsx)(n.code,{children:'"name"'}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"value"})," = new value for that field (e.g., ",(0,t.jsx)(n.code,{children:'"XYZ"'}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"handling-null-fields-safely",children:"Handling Null Fields Safely"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["This approach avoids passing fields with ",(0,t.jsx)(n.code,{children:"null"})," values."]}),"\n",(0,t.jsx)(n.li,{children:"Only specified fields will be updated."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"service-method-outline",children:"Service Method Outline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check if employee exists:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"if (!employeeRepository.existsById(id)) {\n    return null; // or throw custom NotFoundException\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Refactor Repeated Code:"}),"\n",(0,t.jsx)(n.li,{children:"Create a reusable method:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public boolean existsByEmployeeId(Long id) {\n    return employeeRepository.existsById(id);\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Fetch the employee:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Employee employee = employeeRepository.findById(id).orElse(null);\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Apply updates:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Iterate through the ",(0,t.jsx)(n.code,{children:"Map"})," and update only those fields."]}),"\n",(0,t.jsxs)(n.li,{children:["Use reflection or a manual ",(0,t.jsx)(n.code,{children:"if"})," condition per field."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"reflection-based-partial-update-in-java-spring-boot",children:"Reflection-Based Partial Update in Java (Spring Boot)"}),"\n",(0,t.jsx)(n.h3,{id:"entity-presence-check",children:"Entity Presence Check"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Before performing updates, we ensure the employee already exists in the database."}),"\n",(0,t.jsx)(n.li,{children:"Hence, there's no need to re-check for null here."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"error-handling-optional",children:"Error Handling (Optional)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We could wrap the logic inside a ",(0,t.jsx)(n.code,{children:"try-catch"})," block to gracefully handle exceptions."]}),"\n",(0,t.jsx)(n.li,{children:"However, error handling is not the focus at this stage."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"updating-fields-dynamically",children:"Updating Fields Dynamically"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We want to update only the fields provided in the ",(0,t.jsx)(n.code,{children:"updates"})," map."]}),"\n",(0,t.jsxs)(n.li,{children:["Fields not included in the ",(0,t.jsx)(n.code,{children:"updates"})," map should remain unchanged."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"use-of-reflection",children:"Use of Reflection"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Java Reflection allows dynamic access and modification of object fields at runtime."}),"\n",(0,t.jsxs)(n.li,{children:["It enables us to update fields without writing boilerplate ",(0,t.jsx)(n.code,{children:"if-else"})," or ",(0,t.jsx)(n.code,{children:"switch"})," logic."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"iterating-through-updates",children:"Iterating Through Updates"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Loop through each entry in the ",(0,t.jsx)(n.code,{children:"updates"})," map (",(0,t.jsx)(n.code,{children:"Map<String, Object>"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"key"})," represents the field name, and ",(0,t.jsx)(n.code,{children:"value"})," is the new value to be set."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"getting-the-field-object",children:"Getting the Field Object"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"ReflectionUtils.findField(Employee.class, key)"})," to get the corresponding field."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Store the result in a ",(0,t.jsx)(n.code,{children:"Field"})," object (e.g., ",(0,t.jsx)(n.code,{children:"fieldToUpdate"}),")."]}),"\n",(0,t.jsx)(n.h3,{id:"making-field-accessible",children:"Making Field Accessible"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Most fields in the entity are private."}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"fieldToUpdate.setAccessible(true)"})," to allow modification."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"setting-field-value",children:"Setting Field Value"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"ReflectionUtils.setField(fieldToUpdate, employeeEntity, value)"})," to set the new value."]}),"\n",(0,t.jsx)(n.li,{children:"This updates the in-memory entity object with the provided changes."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"saving-the-updated-entity",children:"Saving the Updated Entity"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["After applying all updates, call the ",(0,t.jsx)(n.code,{children:"save()"})," method of the repository."]}),"\n",(0,t.jsx)(n.li,{children:"This persists the changes to the database."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"returning-the-updated-dto",children:"Returning the Updated DTO"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"ModelMapper"})," to convert the updated entity back to a DTO."]}),"\n",(0,t.jsx)(n.li,{children:"Return this DTO as the response."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"why-reflection-is-useful",children:"Why Reflection is Useful"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It reduces repetitive code when updating dynamic fields."}),"\n",(0,t.jsx)(n.li,{children:"Allows updating objects using field names (as strings) at runtime."}),"\n",(0,t.jsx)(n.li,{children:"No need to hard-code field access for each possible property."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"testing-the-patch-endpoint",children:"Testing the PATCH Endpoint"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Created a PATCH endpoint that accepts partial updates."}),"\n",(0,t.jsxs)(n.li,{children:["Tested by updating only the ",(0,t.jsx)(n.code,{children:"name"})," field of employee with ",(0,t.jsx)(n.code,{children:"id=2"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Result: Only ",(0,t.jsx)(n.code,{children:"name"})," was updated; other fields remained unchanged."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code",children:"code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'package com.example.springBootWeb.springBootWeb.controllers;\n\nimport com.example.springBootWeb.springBootWeb.dto.EmployeeDTO;\nimport com.example.springBootWeb.springBootWeb.entities.EmployeeEntity;\nimport com.example.springBootWeb.springBootWeb.repositories.EmployeeRepository;\nimport com.example.springBootWeb.springBootWeb.services.EmployeeService;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport org.springframework.web.bind.annotation.*;\n\nimport java.time.LocalDate;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(path = "/employees")\npublic class EmployeeController {\n\n//    @GetMapping(path = "/getSecretMessage")\n//    public String getMySuperSecretMessage() {\n//        return "Secret message: asdfal@#$DASD";\n//    }\n\n\n    private final EmployeeService employeeService;\n\n    public EmployeeController(EmployeeService employeeService) {\n        this.employeeService = employeeService;\n    }\n\n\n    @GetMapping(path = "/{employeeId}")\n    public EmployeeDTO getEmployeeById(@PathVariable(name = "employeeId") Long id) {\n        return employeeService.getEmployeeById(id);\n    }\n\n    @GetMapping\n    public List<EmployeeDTO> getAllEmployees(@RequestParam(required = false, name = "inputAge") Integer age,\n                                                @RequestParam(required = false) String sortBy) {\n        return employeeService.getAllEmployees();\n    }\n\n    @PostMapping\n    public EmployeeDTO createNewEmployee(@RequestBody EmployeeDTO inputEmployee) {\n        return employeeService.createNewEmployee(inputEmployee);\n    }\n\n    @PutMapping(path = "/{employeeId}")\n    public EmployeeDTO updateEmployeeById(@RequestBody EmployeeDTO employeeDTO, @PathVariable Long employeeId) {\n        return employeeService.updateEmployeeById(employeeId, employeeDTO);\n    }\n\n\n    @DeleteMapping(path= "/{employeeId}")\n    public boolean deleteEmployeeById(@PathVariable Long employeeId) {\n        return employeeService.deleteEmployeeById(employeeId);\n    }\n\n    @PatchMapping(path= "/{employeeId}")\n    public EmployeeDTO updatePartialEmployeeById(@RequestBody Map<String, Object> updates, @PathVariable Long employeeId) {\n        return employeeService.updatePartialEmployeeById(employeeId, updates);\n    }\n\n}\n\n\npackage com.example.springBootWeb.springBootWeb.services;\n\nimport com.example.springBootWeb.springBootWeb.dto.EmployeeDTO;\nimport com.example.springBootWeb.springBootWeb.entities.EmployeeEntity;\nimport com.example.springBootWeb.springBootWeb.repositories.EmployeeRepository;\nimport org.apache.el.util.ReflectionUtil;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.data.util.ReflectionUtils;\nimport org.springframework.stereotype.Service;\n\nimport java.lang.reflect.Field;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n@Service\npublic class EmployeeService {\n\n    private final EmployeeRepository employeeRepository;\n\n    private final ModelMapper modelMapper;\n\n    public EmployeeService(EmployeeRepository employeeRepository, ModelMapper modelMapper) {\n        this.employeeRepository = employeeRepository;\n        this.modelMapper = modelMapper;\n    }\n\n    public EmployeeDTO getEmployeeById(Long id) {\n        EmployeeEntity employeeEntity =  employeeRepository.findById(id).orElse(null);\n        return modelMapper.map(employeeEntity, EmployeeDTO.class);\n    }\n\n    public List<EmployeeDTO> getAllEmployees() {\n        List<EmployeeEntity> employeeEntities =  employeeRepository.findAll();\n        return employeeEntities\n                .stream()\n                .map(employeeEntity -> modelMapper.map(employeeEntity, EmployeeDTO.class))\n                .collect(Collectors.toList());\n    }\n\n    public EmployeeDTO createNewEmployee(EmployeeDTO inputEmployee) {\n        EmployeeEntity toSaveEntity = modelMapper.map(inputEmployee, EmployeeEntity.class);\n        EmployeeEntity savedEmployeeEntities = employeeRepository.save(toSaveEntity);\n        return modelMapper.map(savedEmployeeEntities, EmployeeDTO.class);\n    }\n\n    public EmployeeDTO updateEmployeeById(Long employeeId, EmployeeDTO employeeDTO) {\n        EmployeeEntity employeeEntity = modelMapper.map(employeeDTO, EmployeeEntity.class);\n        employeeEntity.setId(employeeId);\n        EmployeeEntity savedEmployeeEntity = employeeRepository.save(employeeEntity);\n        return modelMapper.map(savedEmployeeEntity, EmployeeDTO.class);\n    }\n\n    public boolean isExistsEmployeeId(Long employeeId){\n        return employeeRepository.existsById(employeeId);\n    }\n    public boolean deleteEmployeeById(Long employeeId) {\n        boolean exists = isExistsEmployeeId(employeeId);\n        if(!exists) return false;\n        employeeRepository.deleteById(employeeId);\n        return true;\n    }\n\n    public EmployeeDTO updatePartialEmployeeById(Long employeeId, Map<String, Object> updates) {\n        boolean exists = isExistsEmployeeId(employeeId);\n        if(!exists) return null;\n        EmployeeEntity employeeEntity = employeeRepository.findById(employeeId).get();\n        updates.forEach((field, value)->{\n            Field fieldToBeUpdated = ReflectionUtils.getRequiredField(EmployeeEntity.class, field);\n            fieldToBeUpdated.setAccessible(true);\n            ReflectionUtils.setField(fieldToBeUpdated, employeeEntity, value);\n        });\n        return modelMapper.map(employeeRepository.save(employeeEntity), EmployeeDTO.class);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"fixes-for-isactive-field-in-json-serialization-with-jackson",children:"Fixes for isActive Field in JSON Serialization with Jackson"}),"\n",(0,t.jsx)(n.h3,{id:"observation-of-patch-behavior",children:"Observation of PATCH Behavior:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When updating a single field (e.g., name), all other fields remain intact."}),"\n",(0,t.jsxs)(n.li,{children:["Demonstrated that updating fields like ",(0,t.jsx)(n.code,{children:"age"})," via PATCH works as intended."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"issue-with-boolean-field-isactive",children:"Issue with Boolean Field isActive:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The field ",(0,t.jsx)(n.code,{children:"isActive"})," was returning ",(0,t.jsx)(n.code,{children:"null"})," even when passed correctly in the JSON."]}),"\n",(0,t.jsx)(n.li,{children:"This was due to Jackson's handling of boolean field naming conventions."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"root-cause-of-the-issue",children:"Root Cause of the Issue:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Jackson tries to map Java boolean fields using getter methods."}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"boolean isActive"}),", Jackson looks for a method named ",(0,t.jsx)(n.code,{children:"getIsActive()"})," but the auto-generated method is typically ",(0,t.jsx)(n.code,{children:"isActive()"}),", causing confusion during deserialization."]}),"\n",(0,t.jsxs)(n.li,{children:["This mismatch results in ",(0,t.jsx)(n.code,{children:"null"})," values or additional unintended fields like ",(0,t.jsx)(n.code,{children:"active"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"fix-with-jsonproperty",children:"Fix with @JsonProperty:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:'@JsonProperty("isActive")'})," annotation on the ",(0,t.jsx)(n.code,{children:"isActive"})," field to explicitly define the property name in JSON."]}),"\n",(0,t.jsx)(n.li,{children:"This helps Jackson map the JSON field isActive correctly to the Java property."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@JsonProperty("isActive")\nprivate Boolean isActive;\n'})}),"\n",(0,t.jsx)(n.h3,{id:"consistency-required-across-dtos-and-entities",children:"Consistency Required Across DTOs and Entities:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Ensure the same ",(0,t.jsx)(n.code,{children:'@JsonProperty("isActive")'})," annotation is used in both DTO and entity classes wherever the ",(0,t.jsx)(n.code,{children:"isActive"})," field is present."]}),"\n",(0,t.jsx)(n.li,{children:"This ensures Jackson consistently serializes and deserializes the field across all layers."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"handling-getters-and-setters",children:"Handling Getters and Setters:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The issue persisted because the default getter/setter names caused Jackson to create conflicting fields like ",(0,t.jsx)(n.code,{children:"active"})," and ",(0,t.jsx)(n.code,{children:"isActive"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["For example:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Getter: ",(0,t.jsx)(n.code,{children:"getActive()"})," instead of ",(0,t.jsx)(n.code,{children:"getIsActive()"})]}),"\n",(0,t.jsxs)(n.li,{children:["Setter: ",(0,t.jsx)(n.code,{children:"setActive()"})," instead of ",(0,t.jsx)(n.code,{children:"setIsActive()"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"solution-with-lombok",children:"Solution with Lombok:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Removed manually written getters and setters."}),"\n",(0,t.jsx)(n.li,{children:"Used Lombok annotations to auto-generate them cleanly, avoiding naming issues:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\npublic class EmployeeDTO {\n    @JsonProperty("isActive")\n    private Boolean isActive;\n    // other fields\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"final-result",children:"Final Result:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["After these changes, JSON now contains only one ",(0,t.jsx)(n.code,{children:"isActive"})," field."]}),"\n",(0,t.jsx)(n.li,{children:"Values are correctly passed from Postman into Java objects and persisted as expected."}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"GET"})," and ",(0,t.jsx)(n.code,{children:"PATCH"})," operations now work properly without duplicating or misnaming fields."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"using-responseentity-to-return-meaningful-http-status-codes",children:"Using ResponseEntity to Return Meaningful HTTP Status Codes"}),"\n",(0,t.jsx)(n.h3,{id:"purpose-of-responseentity",children:"Purpose of ResponseEntity:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In a REST controller, we use ",(0,t.jsx)(n.code,{children:"ResponseEntity"})," to return appropriate HTTP status codes."]}),"\n",(0,t.jsxs)(n.li,{children:["For example:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When a resource is created \u2192 return ",(0,t.jsx)(n.code,{children:"201 Created"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["When a resource is not found \u2192 return ",(0,t.jsx)(n.code,{children:"404 Not Found"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"how-to-use-responseentity",children:["How to Use ",(0,t.jsx)(n.code,{children:"ResponseEntity"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["It is part of the ",(0,t.jsx)(n.code,{children:"org.springframework.http"})," package."]}),"\n",(0,t.jsxs)(n.li,{children:["It can encapsulate any object, such as ",(0,t.jsx)(n.code,{children:"EmployeeDTO"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"returning-responseentity-for-get-by-id",children:"Returning ResponseEntity for Get by ID:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Instead of returning the ",(0,t.jsx)(n.code,{children:"EmployeeDTO"})," directly, wrap it in a ",(0,t.jsx)(n.code,{children:"ResponseEntity"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"if (employeeDto == null) {\n    return ResponseEntity.notFound().build(); // Returns 404\n} else {\n    return ResponseEntity.ok(employeeDto);     // Returns 200\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"handling-null-issues-with-modelmapper",children:"Handling Null Issues with ModelMapper:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the entity is ",(0,t.jsx)(n.code,{children:"null"}),", ",(0,t.jsx)(n.code,{children:"ModelMapper"}),' throws a "Source cannot be null" error.']}),"\n",(0,t.jsxs)(n.li,{children:["To handle this safely, use ",(0,t.jsx)(n.code,{children:"Optional<Employee>"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Optional<Employee> employee = employeeRepository.findById(id);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mapping-optional-entity-to-dto",children:"Mapping Optional Entity to DTO:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Convert the optional entity to DTO using ",(0,t.jsx)(n.code,{children:".map()"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"return employeeRepository.findById(id)\n    .map(emp -> modelMapper.map(emp, EmployeeDTO.class))\n    .map(ResponseEntity::ok)\n    .orElse(ResponseEntity.notFound().build());\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["This returns:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"200 OK with data if present."}),"\n",(0,t.jsx)(n.li,{children:"404 Not Found if the employee is not found."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code-1",children:"code"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import java.time.LocalDate;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\n@RestController\n@RequestMapping(path = "/employees")\npublic class EmployeeController {\n\n//    @GetMapping(path = "/getSecretMessage")\n//    public String getMySuperSecretMessage() {\n//        return "Secret message: asdfal@#$DASD";\n//    }\n\n\n    private final EmployeeService employeeService;\n\n    public EmployeeController(EmployeeService employeeService) {\n        this.employeeService = employeeService;\n    }\n\n    @GetMapping(path = "/{employeeId}")\n    public ResponseEntity<EmployeeDTO> getEmployeeById(@PathVariable(name = "employeeId") Long id) {\n        Optional<EmployeeDTO> employeeDTO = employeeService.getEmployeeById(id);\n        return employeeDTO\n                .map(employeeDTO1 -> ResponseEntity.ok(employeeDTO1))\n                .orElse(ResponseEntity.notFound().build());\n    }\n\n    @GetMapping\n    public ResponseEntity<List<EmployeeDTO>> getAllEmployees(@RequestParam(required = false, name = "inputAge") Integer age,\n                                                @RequestParam(required = false) String sortBy) {\n        return ResponseEntity.ok(employeeService.getAllEmployees());\n    }\n\n    @PostMapping\n    public ResponseEntity<EmployeeDTO> createNewEmployee(@RequestBody EmployeeDTO inputEmployee) {\n        EmployeeDTO savedEmployee = employeeService.createNewEmployee(inputEmployee);\n        return new ResponseEntity<>(savedEmployee, HttpStatus.CREATED);\n    }\n\n\n    @PutMapping(path = "/{employeeId}")\n    public ResponseEntity<EmployeeDTO> updateEmployeeById(@RequestBody EmployeeDTO employeeDTO, @PathVariable Long employeeId) {\n        return ResponseEntity.ok(employeeService.updateEmployeeById(employeeId, employeeDTO));\n    }\n\n    @DeleteMapping(path = "/{employeeId}")\n    public ResponseEntity<Boolean> deleteEmployeeById(@PathVariable Long employeeId) {\n        boolean gotDeleted = employeeService.deleteEmployeeById(employeeId);\n        if (gotDeleted) return ResponseEntity.ok(true);\n        return ResponseEntity.notFound().build();\n    }\n\n    @PatchMapping(path = "/{employeeId}")\n    public ResponseEntity<EmployeeDTO> updatePartialEmployeeById(@RequestBody Map<String, Object> updates,\n                                                 @PathVariable Long employeeId) {\n        EmployeeDTO employeeDTO = employeeService.updatePartialEmployeeById(employeeId, updates);\n        if (employeeDTO == null) return ResponseEntity.notFound().build();\n        return ResponseEntity.ok(employeeDTO);\n    }\n\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"import java.lang.reflect.Field;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\n@Service\npublic class EmployeeService {\n\n    private final EmployeeRepository employeeRepository;\n    private final ModelMapper modelMapper;\n\n    public EmployeeService(EmployeeRepository employeeRepository, ModelMapper modelMapper) {\n        this.employeeRepository = employeeRepository;\n        this.modelMapper = modelMapper;\n    }\n\n\n    public Optional<EmployeeDTO> getEmployeeById(Long id) {\n//        Optional<EmployeeEntity> employeeEntity = employeeRepository.findById(id);\n//        return employeeEntity.map(employeeEntity1 -> modelMapper.map(employeeEntity1, EmployeeDTO.class));\n\n        return employeeRepository.findById(id).map(employeeEntity -> modelMapper.map(employeeEntity, EmployeeDTO.class));\n    }\n\n    public List<EmployeeDTO> getAllEmployees() {\n        List<EmployeeEntity> employeeEntities = employeeRepository.findAll();\n        return employeeEntities\n                .stream()\n                .map(employeeEntity -> modelMapper.map(employeeEntity, EmployeeDTO.class))\n                .collect(Collectors.toList());\n    }\n\n    public EmployeeDTO createNewEmployee(EmployeeDTO inputEmployee) {\n//        to check if user is admin\n//        log something\n        EmployeeEntity toSaveEntity = modelMapper.map(inputEmployee, EmployeeEntity.class);\n        EmployeeEntity savedEmployeeEntity = employeeRepository.save(toSaveEntity);\n        return modelMapper.map(savedEmployeeEntity, EmployeeDTO.class);\n    }\n\n    public EmployeeDTO updateEmployeeById(Long employeeId, EmployeeDTO employeeDTO) {\n        EmployeeEntity employeeEntity = modelMapper.map(employeeDTO, EmployeeEntity.class);\n        employeeEntity.setId(employeeId);\n        EmployeeEntity savedEmployeeEntity = employeeRepository.save(employeeEntity);\n        return modelMapper.map(savedEmployeeEntity, EmployeeDTO.class);\n    }\n\n    public boolean isExistsByEmployeeId(Long employeeId) {\n        return employeeRepository.existsById(employeeId);\n    }\n\n    public boolean deleteEmployeeById(Long employeeId) {\n        boolean exists = isExistsByEmployeeId(employeeId);\n        if(!exists) return false;\n        employeeRepository.deleteById(employeeId);\n        return true;\n    }\n\n    public EmployeeDTO updatePartialEmployeeById(Long employeeId, Map<String, Object> updates) {\n        boolean exists = isExistsByEmployeeId(employeeId);\n        if(!exists) return null;\n        EmployeeEntity employeeEntity = employeeRepository.findById(employeeId).get();\n        updates.forEach((field, value) -> {\n            Field fieldToBeUpdated = ReflectionUtils.findRequiredField(EmployeeEntity.class, field);\n            fieldToBeUpdated.setAccessible(true);\n            ReflectionUtils.setField(fieldToBeUpdated, employeeEntity, value);\n        });\n        return modelMapper.map(employeeRepository.save(employeeEntity), EmployeeDTO.class);\n    }\n}\n361\n"})})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);
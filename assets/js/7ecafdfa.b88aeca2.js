"use strict";(self.webpackChunkes_note=self.webpackChunkes_note||[]).push([[5594],{28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>c});var o=i(96540);const r={},t=o.createContext(r);function a(n){const e=o.useContext(t);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),o.createElement(t.Provider,{value:e},n.children)}},31401:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"advanced-java/0-1/Week-1/1.4","title":"Dependency Injection","description":"Spring Framework - Dependency Injection","source":"@site/docs/advanced-java/0-1/Week-1/1.4.md","sourceDirName":"advanced-java/0-1/Week-1","slug":"/advanced-java/0-1/Week-1/1.4","permalink":"/one-notes/advanced-java/0-1/Week-1/1.4","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/advanced-java/0-1/Week-1/1.4.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Beans","permalink":"/one-notes/advanced-java/0-1/Week-1/1.3"},"next":{"title":"Spring Boot vs Spring Framework","permalink":"/one-notes/advanced-java/0-1/Week-1/1.5"}}');var r=i(74848),t=i(28453);const a={sidebar_position:4},c="Dependency Injection",s={},l=[{value:"Spring Framework - Dependency Injection",id:"spring-framework---dependency-injection",level:2},{value:"Dependency Injection (DI) \u2014 what it is and how it works.",id:"dependency-injection-di--what-it-is-and-how-it-works",level:3},{value:"Analogy for Dependency Injection",id:"analogy-for-dependency-injection",level:3},{value:"Applying the Analogy to Spring",id:"applying-the-analogy-to-spring",level:3},{value:"Why Use Dependency Injection?",id:"why-use-dependency-injection",level:3},{value:"DI Scenario",id:"di-scenario",level:3},{value:"code - 1",id:"code---1",level:3},{value:"code-2",id:"code-2",level:3},{value:"code-3",id:"code-3",level:3},{value:"code-4",id:"code-4",level:3},{value:"Benefits of Dependency Injection (DI) in Spring Framework",id:"benefits-of-dependency-injection-di-in-spring-framework",level:2},{value:"Dependency Injection in Spring",id:"dependency-injection-in-spring",level:2},{value:"Field Injection",id:"field-injection",level:2},{value:"Constructor Injection",id:"constructor-injection",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"dependency-injection",children:"Dependency Injection"})}),"\n",(0,r.jsx)(e.h2,{id:"spring-framework---dependency-injection",children:"Spring Framework - Dependency Injection"}),"\n",(0,r.jsx)(e.p,{children:"Dependency Injection is a design pattern and technique used to achieve loose coupling between components in a software application."}),"\n",(0,r.jsx)(e.h3,{id:"dependency-injection-di--what-it-is-and-how-it-works",children:"Dependency Injection (DI) \u2014 what it is and how it works."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Dependency injection is a core feature of the Spring Framework, not just Spring Boot."}),"\n",(0,r.jsx)(e.li,{children:"It plays a foundational role in building loosely coupled Spring Boot applications \u2014 making it one of the most important concepts you need to master."}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"analogy-for-dependency-injection",children:"Analogy for Dependency Injection"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Let's understand DI using a simple analogy:"}),"\n",(0,r.jsx)(e.li,{children:"Suppose there\u2019s a girl named Alice, who runs a bakery and wants to bake a chocolate cake."}),"\n",(0,r.jsx)(e.li,{children:"However, Alice doesn\u2019t have all the ingredients in her bakery. So she has to go to the market herself to get items like frosting or syrup."}),"\n",(0,r.jsx)(e.li,{children:"This process takes up a lot of her time and distracts her from what she actually enjoys \u2014 baking."}),"\n",(0,r.jsx)(e.li,{children:"To solve this, Alice hires Bob to take care of gathering the ingredients. Now, whenever she needs frosting or syrup, Bob brings them."}),"\n",(0,r.jsx)(e.li,{children:"So, Alice has delegated the task of getting dependencies to Bob."}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"applying-the-analogy-to-spring",children:"Applying the Analogy to Spring"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"In a Spring application, you (the developer) are like Alice, and your code is your bakery."}),"\n",(0,r.jsx)(e.li,{children:"Your code often depends on other components, libraries, or services \u2014 these are your dependencies."}),"\n",(0,r.jsx)(e.li,{children:"Instead of managing these dependencies manually, you delegate that responsibility to Spring\u2019s Dependency Injection framework \u2014 like Bob."}),"\n",(0,r.jsx)(e.li,{children:"Now, Spring is responsible for providing required dependencies when and where needed, based on configuration."}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"why-use-dependency-injection",children:"Why Use Dependency Injection?"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"No manual dependency management: You don't need to write code to create and manage object lifecycles. Spring handles it for you."}),"\n",(0,r.jsx)(e.li,{children:"Loose coupling: Components are not tightly bound to specific implementations. This makes your code more flexible, modular, and easier to test or change."}),"\n",(0,r.jsx)(e.li,{children:"For example, earlier Alice\u2019s bakery only supported chocolate cake. In a tightly coupled system, she would need a whole new bakery to make a strawberry cake."}),"\n",(0,r.jsx)(e.li,{children:"But with loose coupling, she can reuse the same bakery and just change the ingredients."}),"\n",(0,r.jsx)(e.li,{children:"In Spring, this translates to changing configurations or injecting different beans, without changing the entire application structure."}),"\n",(0,r.jsx)(e.li,{children:"For instance, your application can work with different databases (development, staging, production) just by changing the configuration \u2014 without rewriting core logic."}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"di-scenario",children:"DI Scenario"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Instead of a component creating its own dependencies,"}),"\n",(0,r.jsx)(e.li,{children:"The dependencies are injected into the component from an external source \u2014 usually managed by a framework like Spring."}),"\n",(0,r.jsx)(e.li,{children:"You don\u2019t have to manually configure or manage your dependencies."}),"\n",(0,r.jsx)(e.li,{children:"You don\u2019t need to instantiate or inject them yourself."}),"\n",(0,r.jsx)(e.li,{children:"All of this is handled by the IoC (Inversion of Control) container, which includes the Dependency Injection mechanism."}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"code---1",children:"code - 1"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"\u251c\u2500\u2500 DBService.java\n\u251c\u2500\u2500 DevDB.java\n\u251c\u2500\u2500 IntroductionToSpringBootApplication.java\n\u2514\u2500\u2500 ProdDB.java\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"package com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n\n@SpringBootApplication\npublic class IntroductionToSpringBootApplication implements CommandLineRunner {\n\n\t@Autowired\n\tDBService dbService;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(IntroductionToSpringBootApplication.class, args);\n\t}\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println(dbService.getData());\n\t}\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"package com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class DBService {\n\n    @Autowired\n    private DevDB db;\n\n    String getData(){\n        return db.getData();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'package com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DevDB {\n\n    String getData(){\n        return "Dev Data";\n    }\n}\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'package com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ProdDB {\n\n    String getData(){\n        return "Prod Data";\n    }\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Dependency Injection and Loose Coupling in Spring Boot"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"To understand how dependency injection helps achieve loose coupling, let\u2019s take the help of an example."}),"\n",(0,r.jsx)(e.li,{children:"Suppose we have a service that fetches data from a database."}),"\n",(0,r.jsx)(e.li,{children:"Now, our code might need to connect to different databases (e.g., development and production), but we don\u2019t want to write separate applications for each environment."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Problem: Tight Coupling"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"If we hardcode which database to use inside our service, the service becomes tightly coupled to that specific database."}),"\n",(0,r.jsx)(e.li,{children:"For example:"}),"\n",(0,r.jsx)(e.li,{children:"If the DBService is directly using DevDB, then switching to ProdDB would require a code change."}),"\n",(0,r.jsx)(e.li,{children:"This is not ideal for real-world environments where we want to deploy the same codebase to different environments without modification."}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"code-2",children:"code-2"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u251c\u2500\u2500 DB.java\n\u251c\u2500\u2500 DBService.java\n\u251c\u2500\u2500 DevDB.java\n\u251c\u2500\u2500 IntroductionToSpringBootApplication.java\n\u2514\u2500\u2500 ProdDB.java\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'package com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n\n@SpringBootApplication\npublic class IntroductionToSpringBootApplication implements CommandLineRunner {\n\n\t@Autowired\n\tDBService dbService;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(IntroductionToSpringBootApplication.class, args);\n\t}\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println(dbService.getData());\n\t}\n}\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class DBService {\n\n    @Autowired\n    private DB db;\n\n    String getData(){\n        return db.getData();\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DevDB implements DB{\n\n    public String getData(){\n        return "Dev Data";\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ProdDB implements DB{\n\n    public String getData(){\n        return "Prod Data";\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\npublic interface DB {\n    String getData();\n}\n\n\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"How Dependency Injection Helps in Loose Coupling"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Now let\u2019s understand how dependency injection actually helps us in making our system loosely coupled."}),"\n",(0,r.jsx)(e.li,{children:"Define a Specification (Interface)"}),"\n",(0,r.jsx)(e.li,{children:"Create a specification, which is just an interface in Java."}),"\n",(0,r.jsx)(e.li,{children:"This interface will define a contract that all database classes must follow."}),"\n",(0,r.jsx)(e.li,{children:"Both DevDB and ProdDB should implement this DB interface."}),"\n",(0,r.jsx)(e.li,{children:"They must provide their own implementation of the getData() method."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Multiple Bean Ambiguity"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Spring will now try to inject a DB bean."}),"\n",(0,r.jsx)(e.li,{children:"But there are two beans implementing DB:"}),"\n",(0,r.jsx)(e.li,{children:"DevDB"}),"\n",(0,r.jsx)(e.li,{children:"ProdDB"}),"\n",(0,r.jsx)(e.li,{children:"As a result, Spring throws an error:"}),"\n",(0,r.jsx)(e.li,{children:"Expected a single matching bean of type 'DB' but found 2: devDB, prodDB"}),"\n",(0,r.jsx)(e.li,{children:"above will give error"}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"Field db in com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot.DBService required a single bean, but 2 were found:"})}),"\n",(0,r.jsxs)(e.li,{children:["Resolve Ambiguity Using ",(0,r.jsx)(e.code,{children:"@Primary"})]}),"\n",(0,r.jsxs)(e.li,{children:["To fix this, we can use the ",(0,r.jsx)(e.code,{children:"@Primary"})," annotation on one of the beans."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This tells Spring which bean to use by default when there are multiple implementations."}),"\n",(0,r.jsx)(e.h3,{id:"code-3",children:"code-3"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'package com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n\n@SpringBootApplication\npublic class IntroductionToSpringBootApplication implements CommandLineRunner {\n\n\t@Autowired\n\tDBService dbService;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(IntroductionToSpringBootApplication.class, args);\n\t}\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println(dbService.getData());\n\t}\n}\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class DBService {\n\n    @Autowired\n    private DB db;\n\n    String getData(){\n        return db.getData();\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\n@Primary\npublic class DevDB implements DB{\n\n    public String getData(){\n        return "Dev Data";\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ProdDB implements DB{\n\n    public String getData(){\n        return "Prod Data";\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\npublic interface DB {\n    String getData();\n}\n\n\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"When you run the application:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["If ProdDB is marked ",(0,r.jsx)(e.code,{children:"@Primary"}),", it returns ",(0,r.jsx)(e.code,{children:'"Prod Data"'}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["If DevDB is marked ",(0,r.jsx)(e.code,{children:"@Primary"}),", it returns ",(0,r.jsx)(e.code,{children:'"Dev Data"'}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"But Still a Problem: Code is Still Tightly Coupled"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Even though we\u2019re using interfaces and @Primary, we are still editing the code to switch between dev and prod."}),"\n",(0,r.jsx)(e.li,{children:"Changing the primary bean inside the code every time is not true loose coupling."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"To make it truly environment-specific without changing code:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:'Use Spring Profiles (@Profile("dev"), @Profile("prod"))'}),"\n",(0,r.jsx)(e.li,{children:"Use external configuration (e.g., YAML or application.properties)"}),"\n",(0,r.jsx)(e.li,{children:'Use qualifiers (@Qualifier("devDB")) with configuration-driven injection'}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"code-4",children:"code-4"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"spring.application.name=Introduction-to-Spring-Boot\nserver.port=8080\ndeploy.env=production\ndebug=true\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'package com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n\n@SpringBootApplication\npublic class IntroductionToSpringBootApplication implements CommandLineRunner {\n\n\t@Autowired\n\tDBService dbService;\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(IntroductionToSpringBootApplication.class, args);\n\t}\n\t@Override\n\tpublic void run(String... args) throws Exception {\n\t\tSystem.out.println(dbService.getData());\n\t}\n}\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class DBService {\n\n    @Autowired\n    private DB db;\n\n    String getData(){\n        return db.getData();\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\n@ConditionalOnProperty(name = "deploy.env", havingValue = "development")\npublic class DevDB implements DB{\n\n    public String getData(){\n        return "Dev Data";\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\nimport org.springframework.stereotype.Component;\n\n@Component\n@ConditionalOnProperty(name = "deploy.env", havingValue = "production")\npublic class ProdDB implements DB{\n\n    public String getData(){\n        return "Prod Data";\n    }\n}\n\n\n\npackage com.codecrush.ritik.week1Introduction.Introduction.to.Spring.Boot;\n\npublic interface DB {\n    String getData();\n}\n\n\n'})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Conditional Configuration Using Properties"}),"\n",(0,r.jsxs)(e.li,{children:["We define a property in application.properties:\n",(0,r.jsx)(e.code,{children:"deploy.environment=development"})]}),"\n",(0,r.jsxs)(e.li,{children:["we use ",(0,r.jsx)(e.code,{children:"@ConditionalOnProperty"})," in our beans:"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'@Component\n@ConditionalOnProperty(name = "deploy.environment", havingValue = "development")\npublic class DevDB implements DB { ... }\n\n@Component\n@ConditionalOnProperty(name = "deploy.environment", havingValue = "production")\npublic class ProdDB implements DB { ... }\n'})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"This ensures only one bean is created depending on the environment."}),"\n",(0,r.jsx)(e.li,{children:"This approach achieves loose coupling."}),"\n",(0,r.jsx)(e.li,{children:"It provides flexibility to switch between environments using external configuration."}),"\n",(0,r.jsx)(e.li,{children:"It avoids the need for code changes during deployment."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Changing the Environment"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"To switch environments, change the value in application.properties:"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"deploy.environment=production\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Now ProdDB will be injected automatically. No code change is needed \u2014 just configuration."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Verifying with Debug Mode"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"To confirm which beans were created, enable debug mode:"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"debug=true\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"On application startup, Spring will log:"}),"\n",(0,r.jsx)(e.li,{children:"Matched Conditions: Beans and configurations that were created."}),"\n",(0,r.jsx)(e.li,{children:"Unmatched Conditions: Beans that were skipped due to configuration mismatch."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Dynamic Configuration Without Code Changes"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"three dot - edit configurations"}),"\n",(0,r.jsx)(e.li,{children:'You might wonder: "We are still changing code to switch between development and production?"'}),"\n",(0,r.jsx)(e.li,{children:"The key idea is: you can avoid changing code by defining configurations using environment variables."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Environment Variables at the Server Level"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Each operating system or server can have its own set of environment variables."}),"\n",(0,r.jsx)(e.li,{children:"You can define environment-specific configurations (e.g., DEVELOPMENT, PRODUCTION) at the server level, without altering the code."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Defining Custom Configurations in IDE (e.g., IntelliJ)"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Click on the Run/Debug Configurations (gear icon next to the Run button)."}),"\n",(0,r.jsx)(e.li,{children:"Create or edit your configuration."}),"\n",(0,r.jsx)(e.li,{children:"Specify:"}),"\n",(0,r.jsx)(e.li,{children:"The JDK/SDK to use."}),"\n",(0,r.jsx)(e.li,{children:"Any command-line arguments."}),"\n",(0,r.jsx)(e.li,{children:"Environment variables like DEPLOY_ENVIRONMENT=DEVELOPMENT."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Naming Environment Variables Correctly"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Always use uppercase letters."}),"\n",(0,r.jsx)(e.li,{children:"Replace dots (.) with underscores (_)."}),"\n",(0,r.jsx)(e.li,{children:"Example:"}),"\n",(0,r.jsx)(e.li,{children:"deploy.do.environment \u2192 DEPLOY_DO_ENVIRONMENT"}),"\n",(0,r.jsx)(e.li,{children:"Environment Variable Precedence Over application.properties"}),"\n",(0,r.jsx)(e.li,{children:"When you run the application, the value in environment variables will override the one in application.properties."}),"\n",(0,r.jsx)(e.li,{children:"Even if application.properties says production, if your env var is DEPLOY_DO_ENVIRONMENT=DEVELOPMENT, the development config will be used."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"benefits-of-dependency-injection-di-in-spring-framework",children:"Benefits of Dependency Injection (DI) in Spring Framework"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Loose Coupling"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Components are decoupled from their dependencies."}),"\n",(0,r.jsx)(e.li,{children:"This makes the system easier to maintain and test."}),"\n",(0,r.jsx)(e.li,{children:"You can switch databases (e.g., development, test, production) by just changing configuration, not code."}),"\n"]}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:"Flexible Configuration"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Configurations can be defined from multiple external sources."}),"\n",(0,r.jsx)(e.li,{children:"Examples:"}),"\n",(0,r.jsx)(e.li,{children:"application.properties or application.yml"}),"\n",(0,r.jsx)(e.li,{children:"Environment variables"}),"\n",(0,r.jsx)(e.li,{children:"Future topics (like Auto-configuration) will explore more sources."}),"\n",(0,r.jsx)(e.li,{children:"This allows you to easily switch behaviors without touching the source code."}),"\n"]}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:"Improved Testability"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Components can be mocked or replaced during testing."}),"\n",(0,r.jsx)(e.li,{children:"Enables thorough, isolated unit tests."}),"\n",(0,r.jsx)(e.li,{children:"Since components are not tightly coupled, you can test one independently of others."}),"\n"]}),"\n",(0,r.jsxs)(e.ol,{start:"4",children:["\n",(0,r.jsx)(e.li,{children:"System Modularity"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"One component is not tightly bound to another."}),"\n",(0,r.jsx)(e.li,{children:"You can plug in any configuration, any service, or even another database, and it will still work as expected."}),"\n",(0,r.jsx)(e.li,{children:"Encourages modular and maintainable architecture."}),"\n"]}),"\n",(0,r.jsxs)(e.ol,{start:"5",children:["\n",(0,r.jsx)(e.li,{children:"Built-in Support in Spring (No Extra Code Needed)"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"In contrast to other stacks (like MERN/Node.js), where you need to write additional boilerplate code to achieve loose coupling and DI..."}),"\n",(0,r.jsx)(e.li,{children:"Spring Framework provides this out of the box, making it natural and efficient for Java developers."}),"\n"]}),"\n",(0,r.jsxs)(e.ol,{start:"6",children:["\n",(0,r.jsx)(e.li,{children:"Scalable and Maintainable Codebase"}),"\n"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"With DI, your application becomes:"}),"\n",(0,r.jsx)(e.li,{children:"Scalable \u2013 Easy to expand with new components."}),"\n",(0,r.jsx)(e.li,{children:"Maintainable \u2013 Clean separation of concerns."}),"\n",(0,r.jsx)(e.li,{children:"Loosely Coupled \u2013 Promotes reusable and flexible design."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"dependency-injection-in-spring",children:"Dependency Injection in Spring"}),"\n",(0,r.jsx)(e.h2,{id:"field-injection",children:"Field Injection"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Most basic form of dependency injection."}),"\n",(0,r.jsxs)(e.li,{children:["Achieved using the ",(0,r.jsx)(e.code,{children:"@Autowired"})," annotation directly on class fields."]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"@Autowired\nprivate DB db;\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Limitation: Cannot mark the field final (hence mutable)."}),"\n",(0,r.jsx)(e.li,{children:"Not recommended for core dependencies due to tight coupling and testing limitations."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"constructor-injection",children:"Constructor Injection"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Dependencies are injected via the constructor."}),"\n",(0,r.jsx)(e.li,{children:"Encourages immutability and clear visibility of required dependencies."}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"@Service\npublic class DBService {\n\n    private final DB db;\n\n    public DBService(DB db){\n        this.db = db;\n    }\n\n    String getData(){\n        return db.getData();\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Why Constructor Injection is Preferred:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"You can mark fields as final, making them immutable."}),"\n",(0,r.jsx)(e.li,{children:"Makes unit testing easier as dependencies are explicitly provided."}),"\n",(0,r.jsx)(e.li,{children:"Helps in clear dependency management \u2013 you know what the class needs to function."}),"\n",(0,r.jsx)(e.li,{children:"Supports early failure if a required dependency is missing."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.code,{children:"If the dependency is required for the object to work, inject it via the constructor. If it's optional or secondary, then setter or field injection may be acceptable"})})]})}function p(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);
"use strict";(self.webpackChunkes_note=self.webpackChunkes_note||[]).push([[437],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(96540);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},70497:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core-java/Method Reference/1","title":"Intro","description":"System.out::println ek method reference hai jo System.out.println() method ka shorthand notation hai.","source":"@site/docs/core-java/Method Reference/1.md","sourceDirName":"core-java/Method Reference","slug":"/core-java/Method Reference/1","permalink":"/one-notes/core-java/Method Reference/1","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/core-java/Method Reference/1.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Type Erasure","permalink":"/one-notes/core-java/Generics/9"},"next":{"title":"Functional Interface","permalink":"/one-notes/category/functional-interface"}}');var a=t(74848),i=t(28453);const o={sidebar_position:1},s="Intro",c={},l=[{value:"Method Reference in Java (Java 8)",id:"method-reference-in-java-java-8",level:2},{value:"Syntax of Method Reference",id:"syntax-of-method-reference",level:3},{value:"Types of Method References",id:"types-of-method-references",level:3},{value:"1\ufe0f\u20e3 Reference to a Static Method",id:"1\ufe0f\u20e3-reference-to-a-static-method",level:3},{value:"2 Reference to an Instance Method of a Particular Object",id:"2-reference-to-an-instance-method-of-a-particular-object",level:3},{value:"3 Reference to an Instance Method of an Arbitrary Object",id:"3-reference-to-an-instance-method-of-an-arbitrary-object",level:3},{value:"4 Reference to a Constructor",id:"4-reference-to-a-constructor",level:3},{value:"Why Use Method References?",id:"why-use-method-references",level:3}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"intro",children:"Intro"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"System.out::println"})," ek method reference hai jo ",(0,a.jsx)(n.code,{children:"System.out.println()"})," method ka shorthand notation hai.",(0,a.jsx)(n.br,{}),"\n","Yeh Java 8 ke ",(0,a.jsx)(n.strong,{children:"Method Reference"})," feature ka ek part hai, jo lambda expressions ko aur concise banata hai."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");\n\n        // Using method reference\n        names.forEach(System.out::println);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"msg -> System.out.println(msg)\nnames.forEach(name -> System.out.println(name));\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'class Demo {\n    static void show(String msg) {\n        System.out.println(msg);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = Arrays.asList("Hello", "World");\n\n        // Using method reference\n        list.forEach(Demo::show);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"method-reference-in-java-java-8",children:"Method Reference in Java (Java 8)"}),"\n",(0,a.jsx)(n.p,{children:"A method reference in Java is a shorthand way of referring to a method without executing it. It is used with lambda expressions to improve readability."}),"\n",(0,a.jsx)(n.h3,{id:"syntax-of-method-reference",children:"Syntax of Method Reference"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"It is used when a lambda expression calls an existing method."}),"\n",(0,a.jsx)(n.li,{children:"It makes code shorter and more readable."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"types-of-method-references",children:"Types of Method References"}),"\n",(0,a.jsx)(n.p,{children:"There are four types of method references:"}),"\n",(0,a.jsxs)(n.p,{children:["1\ufe0f\u20e3 ",(0,a.jsx)(n.strong,{children:"Reference to a Static Method"}),(0,a.jsx)(n.br,{}),"\n","2\ufe0f\u20e3 ",(0,a.jsx)(n.strong,{children:"Reference to an Instance Method of a Particular Object"}),(0,a.jsx)(n.br,{}),"\n","3\ufe0f\u20e3 ",(0,a.jsx)(n.strong,{children:"Reference to an Instance Method of an Arbitrary Object"}),(0,a.jsx)(n.br,{}),"\n","4\ufe0f\u20e3 ",(0,a.jsx)(n.strong,{children:"Reference to a Constructor"})]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"1\ufe0f\u20e3-reference-to-a-static-method",children:"1\ufe0f\u20e3 Reference to a Static Method"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"ClassName::staticMethodName\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"import java.util.function.Function;\n\npublic class StaticMethodReference {\n    // Static method\n    public static int square(int num) {\n        return num * num;\n    }\n\n    public static void main(String[] args) {\n        // Using Lambda Expression\n        Function<Integer, Integer> lambdaSquare = num -> StaticMethodReference.square(num);\n\n        // Using Method Reference\n        Function<Integer, Integer> methodRefSquare = StaticMethodReference::square;\n\n        System.out.println(methodRefSquare.apply(5)); // Output: 25\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-reference-to-an-instance-method-of-a-particular-object",children:"2 Reference to an Instance Method of a Particular Object"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"objectRef::instanceMethodName\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.function.Supplier;\n\npublic class InstanceMethodReference {\n    public String greet() {\n        return "Hello, Method Reference!";\n    }\n\n    public static void main(String[] args) {\n        InstanceMethodReference obj = new InstanceMethodReference();\n\n        // Using Lambda Expression\n        Supplier<String> lambdaGreet = () -> obj.greet();\n\n        // Using Method Reference\n        Supplier<String> methodRefGreet = obj::greet;\n\n        System.out.println(methodRefGreet.get()); // Output: Hello, Method Reference!\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-reference-to-an-instance-method-of-an-arbitrary-object",children:"3 Reference to an Instance Method of an Arbitrary Object"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"ClassName::instanceMethodName\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.Arrays;\nimport java.util.List;\n\npublic class ArbitraryObjectMethodReference {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");\n\n        // Using Lambda Expression\n        names.forEach(name -> System.out.println(name));\n\n        // Using Method Reference\n        names.forEach(System.out::println);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-reference-to-a-constructor",children:"4 Reference to a Constructor"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"ClassName::new\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.function.Supplier;\n\nclass Car {\n    Car() {\n        System.out.println("Car is created!");\n    }\n}\n\npublic class ConstructorReference {\n    public static void main(String[] args) {\n        // Using Lambda Expression\n        Supplier<Car> lambdaCar = () -> new Car();\n\n        // Using Constructor Reference\n        Supplier<Car> methodRefCar = Car::new;\n\n        // Creates a new Car object\n        methodRefCar.get();\n    }\n}\n\n// Car is created!\n'})}),"\n",(0,a.jsx)(n.h3,{id:"why-use-method-references",children:"Why Use Method References?"}),"\n",(0,a.jsx)(n.p,{children:"\u2705 Reduces code complexity\n\u2705 Improves readability\n\u2705 Prevents redundant lambda expressions"}),"\n",(0,a.jsx)(n.p,{children:"\ud83d\udcdd Example 1: Constructor with One Parameter"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.function.Function;\n\nclass Car {\n    private String brand;\n\n    // Parameterized Constructor\n    public Car(String brand) {\n        this.brand = brand;\n        System.out.println("Car brand: " + brand);\n    }\n}\n\npublic class ConstructorReferenceExample {\n    public static void main(String[] args) {\n        // Using Lambda Expression\n        Function<String, Car> lambdaCar = brand -> new Car(brand);\n\n        // Using Constructor Reference\n        Function<String, Car> methodRefCar = Car::new;\n\n        // Creating an object\n        methodRefCar.apply("Toyota"); // Output: Car brand: Toyota\n    }\n}\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"\ud83d\udcdd Example 2: Constructor with Two Parameters"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.function.BiFunction;\n\nclass Bike {\n    private String brand;\n    private int price;\n\n    // Parameterized Constructor\n    public Bike(String brand, int price) {\n        this.brand = brand;\n        this.price = price;\n        System.out.println("Bike brand: " + brand + ", Price: " + price);\n    }\n}\n\npublic class ConstructorReferenceExample {\n    public static void main(String[] args) {\n        // Using Lambda Expression\n        BiFunction<String, Integer, Bike> lambdaBike = (brand, price) -> new Bike(brand, price);\n\n        // Using Constructor Reference\n        BiFunction<String, Integer, Bike> methodRefBike = Bike::new;\n\n        // Creating an object\n        methodRefBike.apply("Yamaha", 100000); // Output: Bike brand: Yamaha, Price: 100000\n    }\n}\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"\ud83d\udcdd Example 3: Constructor with Multiple Parameters and Custom Functional Interface\nIf more than two parameters are required, create a custom functional interface."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.function.Function;\n\n// Functional Interface for three parameters\n@FunctionalInterface\ninterface TriFunction<T, U, V, R> {\n    R apply(T t, U u, V v);\n}\n\nclass Person {\n    private String name;\n    private int age;\n    private String city;\n\n    // Parameterized Constructor\n    public Person(String name, int age, String city) {\n        this.name = name;\n        this.age = age;\n        this.city = city;\n        System.out.println("Person: " + name + ", Age: " + age + ", City: " + city);\n    }\n}\n\npublic class ConstructorReferenceExample {\n    public static void main(String[] args) {\n        // Using Lambda Expression\n        TriFunction<String, Integer, String, Person> lambdaPerson = (name, age, city) -> new Person(name, age, city);\n\n        // Using Constructor Reference\n        TriFunction<String, Integer, String, Person> methodRefPerson = Person::new;\n\n        // Creating an object\n        methodRefPerson.apply("John", 25, "New York");\n    }\n}\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"\ud83d\udd39 Why Use Constructor References for Parameterized Constructors?\n\u2705 Shortens lambda expressions\n\u2705 Increases readability\n\u2705 Works dynamically with different parameter types"}),"\n",(0,a.jsx)(n.p,{children:"Key Benefits of Method References\nImproved Readability: Method references simplify the code by removing boilerplate syntax.\nReusability: Existing methods can be directly reused, enhancing modularity.\nFunctional Programming Support: They work seamlessly with functional interfaces and lambdas."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"Converting ArrayList to HashMap using Method Reference in Java 8\n\ud83d\udcdd Simple Explanation:\n\u2022 We have an ArrayList of Strings.\n\u2022 We need to convert it into a HashMap where:\n\u25cb The key is the element itself.\n\u25cb The value is the length of the string.\nMethod Reference (Function.identity() and String::length) makes the code cleaner."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'import java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create an ArrayList of Strings\n        List<String> fruits = Arrays.asList("Banana", "Guava", "Pineapple", "Apple");\n\n        // Convert ArrayList to HashMap using Method Reference\n        Map<String, Integer> fruitMap = fruits.stream()\n                .collect(Collectors.toMap(\n                        Function.identity(),  // Key -> element itself\n                        String::length        // Value -> length of the string\n                ));\n\n        // Print the HashMap\n        System.out.println(fruitMap);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"\ud83d\udcdd Explanation of collect(Collectors.toMap(...))\n\u2022 Function.identity() \u2192 Uses the element itself as the key.\n\u2022 String::length \u2192 Uses the length of the string as the value.\n\ud83d\udda5 Output:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"{Guava=5, Apple=5, Pineapple=9, Banana=6}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);
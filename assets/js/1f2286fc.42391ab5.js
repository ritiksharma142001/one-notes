"use strict";(globalThis.webpackChunkes_note=globalThis.webpackChunkes_note||[]).push([[7393],{833(n,e,s){s.r(e),s.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-java/OOPS/Polymorphism","title":"Polymorphism","description":"Polymorphism in Java","source":"@site/docs/core-java/OOPS/4. Polymorphism.md","sourceDirName":"core-java/OOPS","slug":"/core-java/OOPS/Polymorphism","permalink":"/one-notes/core-java/OOPS/Polymorphism","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/core-java/OOPS/4. Polymorphism.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Inheritance","permalink":"/one-notes/core-java/OOPS/Inheritance"},"next":{"title":"Abstraction","permalink":"/one-notes/core-java/OOPS/Abstraction"}}');var t=s(4848),r=s(8453);const o={sidebar_position:4},a=void 0,l={},c=[{value:"<strong>Polymorphism in Java</strong>",id:"polymorphism-in-java",level:3},{value:"<strong>What is Polymorphism?</strong>",id:"what-is-polymorphism",level:4},{value:"<strong>Method Overloading</strong>",id:"method-overloading",level:3},{value:"<strong>Method Overriding</strong>",id:"method-overriding",level:3},{value:"<strong>Difference Between Method Overloading and Method Overriding</strong>",id:"difference-between-method-overloading-and-method-overriding",level:3},{value:"<strong>Rules of Method Overriding</strong>",id:"rules-of-method-overriding",level:3},{value:"<strong>Key Takeaways:</strong>",id:"key-takeaways",level:3},{value:"<strong>Polymorphism and Casting in Java</strong>",id:"polymorphism-and-casting-in-java",level:3},{value:"<strong>1. What is Casting?</strong>",id:"1-what-is-casting",level:4},{value:"<strong>2. What is Polymorphism?</strong>",id:"2-what-is-polymorphism",level:4},{value:"<strong>3. Types of Casting in Java</strong>",id:"3-types-of-casting-in-java",level:4},{value:"<strong>4. Advantages of Polymorphism</strong>",id:"4-advantages-of-polymorphism",level:4},{value:"<strong>5. Example of Polymorphism using Upcasting and Method Overriding</strong>",id:"5-example-of-polymorphism-using-upcasting-and-method-overriding",level:4},{value:"<strong>6. Explanation of the Code</strong>",id:"6-explanation-of-the-code",level:4},{value:"<strong>Conclusion</strong>",id:"conclusion",level:3},{value:"<strong>Polymorphism, Casting, and Downcasting in Java</strong>",id:"polymorphism-casting-and-downcasting-in-java",level:3},{value:"<strong>1. What is Downcasting?</strong>",id:"1-what-is-downcasting",level:4},{value:"<strong>2. Example of Downcasting in Java</strong>",id:"2-example-of-downcasting-in-java",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code",level:4},{value:"<strong>4. Conclusion</strong>",id:"4-conclusion",level:3},{value:"<strong>Aggregation and Composition in Java</strong>",id:"aggregation-and-composition-in-java",level:3},{value:"<strong>1. What is Aggregation?</strong>",id:"1-what-is-aggregation",level:4},{value:"<strong>2. Example of Aggregation in Java</strong>",id:"2-example-of-aggregation-in-java",level:4},{value:"<strong>3. Explanation of Aggregation Code</strong>",id:"3-explanation-of-aggregation-code",level:4},{value:"<strong>4. What is Composition?</strong>",id:"4-what-is-composition",level:4},{value:"<strong>5. Example of Composition in Java</strong>",id:"5-example-of-composition-in-java",level:4},{value:"<strong>6. Explanation of Composition Code</strong>",id:"6-explanation-of-composition-code",level:4},{value:"<strong>7. Differences Between Aggregation and Composition</strong>",id:"7-differences-between-aggregation-and-composition",level:3},{value:"<strong>8. Conclusion</strong>",id:"8-conclusion",level:3},{value:"<strong>Understanding Java Program Execution: JVM, Static, and Non-Static Elements</strong>",id:"understanding-java-program-execution-jvm-static-and-non-static-elements",level:3},{value:"<strong>1. How Java Program Execution Starts</strong>",id:"1-how-java-program-execution-starts",level:4},{value:"<strong>2. Rules for Static and Non-Static Elements</strong>",id:"2-rules-for-static-and-non-static-elements",level:4},{value:"<strong>3. Java Program Demonstrating Static and Non-Static Elements</strong>",id:"3-java-program-demonstrating-static-and-non-static-elements",level:4},{value:"<strong>4. Explanation of the Code</strong>",id:"4-explanation-of-the-code",level:4},{value:"<strong>5. Summary</strong>",id:"5-summary",level:4}];function d(n){const e={code:"code",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h3,{id:"polymorphism-in-java",children:(0,t.jsx)(e.strong,{children:"Polymorphism in Java"})}),"\n",(0,t.jsx)(e.h4,{id:"what-is-polymorphism",children:(0,t.jsx)(e.strong,{children:"What is Polymorphism?"})}),"\n",(0,t.jsx)(e.p,{children:"Polymorphism in Java is the ability of an object to take many forms. It allows a single method, interface, or class to operate in different ways based on the context. There are two main types of polymorphism:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Compile-time Polymorphism (Method Overloading)"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Runtime Polymorphism (Method Overriding)"})}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"method-overloading",children:(0,t.jsx)(e.strong,{children:"Method Overloading"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Definition:"}),"\nMethod Overloading is a process where multiple methods have the same name but different parameters within the same class."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"It happens in the same class."}),"\n",(0,t.jsx)(e.li,{children:"The method name remains the same, but the parameters (number, type, or both) differ."}),"\n",(0,t.jsxs)(e.li,{children:["It is an example of ",(0,t.jsx)(e.strong,{children:"Compile-time Polymorphism"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"It does not require inheritance."}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class MathOperations {\n    int add(int a, int b) {\n        return a + b;\n    }\n    double add(double a, double b) {\n        return a + b;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"method-overriding",children:(0,t.jsx)(e.strong,{children:"Method Overriding"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Definition:"}),"\nMethod Overriding is a process where a method from the parent class is redefined in the child class with the same name and parameters but a different implementation."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Points:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"It happens in different classes (parent-child relationship)."}),"\n",(0,t.jsx)(e.li,{children:"The method name and parameters remain the same, but the implementation is different."}),"\n",(0,t.jsxs)(e.li,{children:["It is an example of ",(0,t.jsx)(e.strong,{children:"Runtime Polymorphism"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"Inheritance is required."}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'class Parent {\n    void show() {\n        System.out.println("This is the parent class.");\n    }\n}\nclass Child extends Parent {\n    void show() {\n        System.out.println("This is the child class.");\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"difference-between-method-overloading-and-method-overriding",children:(0,t.jsx)(e.strong,{children:"Difference Between Method Overloading and Method Overriding"})}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Feature"}),(0,t.jsx)(e.th,{children:"Method Overloading"}),(0,t.jsx)(e.th,{children:"Method Overriding"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Definition"})}),(0,t.jsx)(e.td,{children:"Multiple methods with the same name but different parameters."}),(0,t.jsx)(e.td,{children:"Redefining a method from the parent class in the child class."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Where It Occurs"})}),(0,t.jsx)(e.td,{children:"Within the same class."}),(0,t.jsx)(e.td,{children:"In a parent-child class relationship."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Parameters"})}),(0,t.jsx)(e.td,{children:"Must be different."}),(0,t.jsx)(e.td,{children:"Must be the same."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Return Type"})}),(0,t.jsx)(e.td,{children:"Can be different."}),(0,t.jsx)(e.td,{children:"Must be the same (or a covariant return type)."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Inheritance"})}),(0,t.jsx)(e.td,{children:"Not required."}),(0,t.jsx)(e.td,{children:"Required."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Polymorphism Type"})}),(0,t.jsx)(e.td,{children:"Compile-time Polymorphism."}),(0,t.jsx)(e.td,{children:"Runtime Polymorphism."})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"rules-of-method-overriding",children:(0,t.jsx)(e.strong,{children:"Rules of Method Overriding"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Access Modifiers:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["The access modifier of the overridden method in the child class ",(0,t.jsx)(e.strong,{children:"must be the same or more accessible"})," than the parent class method."]}),"\n",(0,t.jsxs)(e.li,{children:["Example: If the parent method is ",(0,t.jsx)(e.code,{children:"protected"}),", the child method can be ",(0,t.jsx)(e.code,{children:"protected"})," or ",(0,t.jsx)(e.code,{children:"public"}),", but ",(0,t.jsx)(e.strong,{children:"not"})," ",(0,t.jsx)(e.code,{children:"private"}),"."]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Private methods cannot be overridden."})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Return Type:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["The return type must be ",(0,t.jsx)(e.strong,{children:"the same"})," or a ",(0,t.jsx)(e.strong,{children:"covariant return type"})," (i.e., a subclass of the parent class's return type)."]}),"\n",(0,t.jsxs)(e.li,{children:["Example:","\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:"class Parent {\n    Parent display() { return new Parent(); }\n}\nclass Child extends Parent {\n    Child display() { return new Child(); }\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Final Methods:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Methods declared as ",(0,t.jsx)(e.code,{children:"final"})," in the parent class ",(0,t.jsx)(e.strong,{children:"cannot"})," be overridden."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Static Methods:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Static methods ",(0,t.jsx)(e.strong,{children:"cannot be overridden"}),"; they are method-hidden instead."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Constructor Overriding:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Constructors cannot be overridden"}),", but they can be accessed using ",(0,t.jsx)(e.code,{children:"super()"})," in the child class."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Exception Handling:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["If the parent method declares an exception, the child class method ",(0,t.jsx)(e.strong,{children:"can only declare the same exception or its subclass"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Examples of Method Overriding Rules:"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Access Modifier Rule"})," (Valid Overriding):"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'class Program1 {\n    protected void display() {\n        System.out.println("Parent class method");\n    }\n}\nclass Program2 extends Program1 {\n    public void display() { // Allowed: Increasing visibility\n        System.out.println("Child class method");\n    }\n}\n'})}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Private Method Overriding (Invalid - Compilation Error):"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'class Parent {\n    private void display() {\n        System.out.println("Parent class method");\n    }\n}\nclass Child extends Parent {\n    void display() { // Error: Cannot override a private method\n        System.out.println("Child class method");\n    }\n}\n'})}),"\n",(0,t.jsxs)(e.ol,{start:"3",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Final Method Overriding (Invalid - Compilation Error):"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'class Parent {\n    final void show() {\n        System.out.println("Final method in Parent");\n    }\n}\nclass Child extends Parent {\n    void show() { // Error: Cannot override final method\n        System.out.println("Trying to override final method");\n    }\n}\n'})}),"\n",(0,t.jsxs)(e.ol,{start:"4",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Static Method Overriding (Not Allowed - Method Hiding Instead):"})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'class Parent {\n    static void display() {\n        System.out.println("Static method in Parent");\n    }\n}\nclass Child extends Parent {\n    static void display() { // This is method hiding, not overriding\n        System.out.println("Static method in Child");\n    }\n}\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"key-takeaways",children:(0,t.jsx)(e.strong,{children:"Key Takeaways:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Method Overloading"})," allows multiple methods with the same name but different parameters."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Method Overriding"})," allows a child class to modify a method from the parent class."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Overriding requires inheritance"}),", while overloading does not."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Rules of Overriding"})," ensure proper method redefinition, including access modifiers, return types, and exceptions."]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["\ud83d\ude80 ",(0,t.jsx)(e.strong,{children:"Understanding these concepts is crucial for mastering Java's OOP principles!"})]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://github.com/user-attachments/assets/84c6ad91-51ef-4a42-ac94-6c0b5515e2e0",alt:"image"})}),"\n",(0,t.jsx)(e.h3,{id:"polymorphism-and-casting-in-java",children:(0,t.jsx)(e.strong,{children:"Polymorphism and Casting in Java"})}),"\n",(0,t.jsx)(e.h4,{id:"1-what-is-casting",children:(0,t.jsx)(e.strong,{children:"1. What is Casting?"})}),"\n",(0,t.jsx)(e.p,{children:"Casting is the process of creating a child object and assigning it to a parent type reference variable. This allows us to use a child class object with a reference of its parent class."}),"\n",(0,t.jsx)(e.h4,{id:"2-what-is-polymorphism",children:(0,t.jsx)(e.strong,{children:"2. What is Polymorphism?"})}),"\n",(0,t.jsxs)(e.p,{children:['Polymorphism means "many forms." It allows one interface (or method) to be used for different types of objects. In Java, polymorphism is achieved through ',(0,t.jsx)(e.strong,{children:"method overriding"})," and ",(0,t.jsx)(e.strong,{children:"upcasting"}),"."]}),"\n",(0,t.jsx)(e.h4,{id:"3-types-of-casting-in-java",children:(0,t.jsx)(e.strong,{children:"3. Types of Casting in Java"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Upcasting (Implicit Casting)"}),": Assigning a child class object to a parent class reference."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Downcasting (Explicit Casting)"}),": Assigning a parent class reference back to a child class object (requires explicit casting)."]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"4-advantages-of-polymorphism",children:(0,t.jsx)(e.strong,{children:"4. Advantages of Polymorphism"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Code Flexibility"}),": A single reference type can be used to call different child class methods."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Code Reusability"}),": No need to write separate code for each child class."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Extensibility"}),": New child classes can be added without modifying existing code."]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"5-example-of-polymorphism-using-upcasting-and-method-overriding",children:(0,t.jsx)(e.strong,{children:"5. Example of Polymorphism using Upcasting and Method Overriding"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Parent class\nclass Teacher {\n    void teach() {\n        System.out.println("Teaching general subjects");\n    }\n    \n    void project() {\n        System.out.println("Guiding a general project");\n    }\n}\n\n// Child class: JavaTeacher\nclass JavaTeacher extends Teacher {\n    @Override\n    void teach() {\n        System.out.println("Teaching Java");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Guiding a Java project");\n    }\n}\n\n// Child class: SQLTeacher\nclass SQLTeacher extends Teacher {\n    @Override\n    void teach() {\n        System.out.println("Teaching SQL");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Guiding an SQL project");\n    }\n}\n\n// Main Application class\npublic class TeacherApp {\n    public static void main(String[] args) {\n        // Upcasting: Parent class reference holding a child class object\n        Teacher t1 = new JavaTeacher();\n        t1.teach();  // Calls overridden method of JavaTeacher\n        t1.project();\n\n        Teacher t2 = new SQLTeacher();\n        t2.teach();  // Calls overridden method of SQLTeacher\n        t2.project();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"6-explanation-of-the-code",children:(0,t.jsx)(e.strong,{children:"6. Explanation of the Code"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Upcasting is used"})," (",(0,t.jsx)(e.code,{children:"Teacher t1 = new JavaTeacher();"}),")."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Method Overriding is used"})," (Child classes override the ",(0,t.jsx)(e.code,{children:"teach()"})," and ",(0,t.jsx)(e.code,{children:"project()"})," methods)."]}),"\n",(0,t.jsxs)(e.li,{children:["The ",(0,t.jsx)(e.strong,{children:"parent class reference"})," calls methods from the child class dynamically."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"conclusion",children:(0,t.jsx)(e.strong,{children:"Conclusion"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Casting"})," helps in achieving ",(0,t.jsx)(e.strong,{children:"polymorphism"})," in Java."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Polymorphism increases flexibility"})," by allowing a single reference type to call different implementations of methods."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Method Overriding"})," ensures that child class implementations are used dynamically."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// Parent class\nclass Teacher {\n    void teach() {\n        System.out.println("Teaching general subjects");\n    }\n    \n    void project() {\n        System.out.println("Guiding a general project");\n    }\n}\n\n// Child class: JavaTeacher\nclass JavaTeacher extends Teacher {\n    @Override\n    void teach() {\n        System.out.println("Teaching Java");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Guiding a Java project");\n    }\n}\n\n// Child class: SQLTeacher\nclass SQLTeacher extends Teacher {\n    @Override\n    void teach() {\n        System.out.println("Teaching SQL");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Guiding an SQL project");\n    }\n}\n\n// Main Application class\npublic class TeacherApp {\n    // Static method to call Teacher references\n    static void teacherInfo(Teacher teacher) {\n        teacher.teach();\n        teacher.project();\n    }\n    \n    public static void main(String[] args) {\n        // Calling static method with different teacher objects\n        teacherInfo(new JavaTeacher());\n        teacherInfo(new SQLTeacher());\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"polymorphism-casting-and-downcasting-in-java",children:(0,t.jsx)(e.strong,{children:"Polymorphism, Casting, and Downcasting in Java"})}),"\n",(0,t.jsx)(e.h4,{id:"1-what-is-downcasting",children:(0,t.jsx)(e.strong,{children:"1. What is Downcasting?"})}),"\n",(0,t.jsx)(e.p,{children:"Downcasting is the process of converting a parent class reference to a child class reference explicitly. This allows access to child-specific methods that are not available in the parent class."}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Instance of Operator ("}),(0,t.jsxs)(e.strong,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"instanceof"})})}),"********************)"]}),": Before performing downcasting, the ",(0,t.jsx)(e.code,{children:"instanceof"})," operator is used to check if an object belongs to a particular class. This prevents runtime errors such as ",(0,t.jsx)(e.code,{children:"ClassCastException"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"2-example-of-downcasting-in-java",children:(0,t.jsx)(e.strong,{children:"2. Example of Downcasting in Java"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Parent class\nclass Developer {\n    void project() {\n        System.out.println("Working on a project");\n    }\n    \n    void attendMeeting() {\n        System.out.println("Attending a developer meeting");\n    }\n}\n\n// Child class: BackendDeveloper\nclass BackendDeveloper extends Developer {\n    void backendTeam() {\n        System.out.println("Working with backend team");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Developing backend services");\n    }\n}\n\n// Main Application class\npublic class DeveloperApp {\n    public static void main(String[] args) {\n        // Upcasting: Parent reference holding a child class object\n        Developer dev = new BackendDeveloper();\n        dev.attendMeeting(); // Calls inherited method\n        dev.project();  // Calls overridden method\n        \n        // Trying to call child-specific method (not accessible with parent reference)\n        // dev.backendTeam();  // This will cause a compilation error\n        ((BackendDeveloper)(dev)).backendTeam();\n        // Downcasting: Converting parent reference back to child reference\n        if (dev instanceof BackendDeveloper) {\n            BackendDeveloper backendDev = (BackendDeveloper) dev;\n            backendDev.backendTeam(); // Now we can call child-specific method\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"3-explanation-of-the-code",children:(0,t.jsx)(e.strong,{children:"3. Explanation of the Code"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Upcasting is performed"})," (",(0,t.jsx)(e.code,{children:"Developer dev = new BackendDeveloper();"}),")."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:["Inherited method ",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"attendMeeting()"})})})})})})})})})})})})})," is called"]})," from the parent class."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:["Overridden method ",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"project()"})})})})})})})})})})})})})," is called"]}),", which executes the child class's version."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:["Directly calling ",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"backendTeam()"})})})})})})})})})})})})})," using ",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"dev"})})})})})})})})})})})})})," is not possible"]}),", as ",(0,t.jsx)(e.code,{children:"dev"})," is a ",(0,t.jsx)(e.code,{children:"Developer"})," type."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Downcasting is performed"})," using explicit casting (",(0,t.jsx)(e.code,{children:"(BackendDeveloper) dev"}),"), allowing access to ",(0,t.jsx)(e.code,{children:"backendTeam()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"instanceof"})}),"** operator ensures safe downcasting**, preventing runtime exceptions."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"4-conclusion",children:(0,t.jsx)(e.strong,{children:"4. Conclusion"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Downcasting enables access to child-specific methods"})," when using parent-type references."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"instanceof"})}),"** operator helps prevent ****",(0,t.jsx)(e.code,{children:"ClassCastException"}),"**."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Method overriding ensures that the correct method is invoked at runtime"}),", even with an upcasted reference."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// Parent class\nclass Developer {\n    void project() {\n        System.out.println("Working on a project");\n    }\n    \n    void attendMeeting() {\n        System.out.println("Attending a developer meeting");\n    }\n}\n\n// Child class: BackendDeveloper\nclass BackendDeveloper extends Developer {\n    void backendTeam() {\n        System.out.println("Working with backend team");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Developing backend services");\n    }\n}\n\n// Child class: FrontendDeveloper\nclass FrontendDeveloper extends Developer {\n    void frontendTeam() {\n        System.out.println("Working with frontend team");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Developing frontend applications");\n    }\n}\n\n// Main Application class\npublic class DeveloperApp {\n    // Static method to check developer type\n    static void web(Developer dev) {\n        dev.attendMeeting(); // Calls inherited method\n        dev.project();  // Calls overridden method\n\n        if (dev instanceof BackendDeveloper) {\n            BackendDeveloper backendDev = (BackendDeveloper) dev;\n            backendDev.backendTeam(); // Calls backend-specific method\n        } else if (dev instanceof FrontendDeveloper) {\n            FrontendDeveloper frontendDev = (FrontendDeveloper) dev;\n            frontendDev.frontendTeam(); // Calls frontend-specific method\n        }\n    }\n    \n    public static void main(String[] args) {\n        Developer backendDev = new BackendDeveloper();\n        Developer frontendDev = new FrontendDeveloper();\n        \n        web(backendDev);\n        web(frontendDev);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"aggregation-and-composition-in-java",children:(0,t.jsx)(e.strong,{children:"Aggregation and Composition in Java"})}),"\n",(0,t.jsx)(e.h4,{id:"1-what-is-aggregation",children:(0,t.jsx)(e.strong,{children:"1. What is Aggregation?"})}),"\n",(0,t.jsxs)(e.p,{children:['Aggregation is a process of achieving a "has-a" relationship between objects where they are loosely coupled. This means that one object can exist independently of the other. For example, a ',(0,t.jsx)(e.code,{children:"Car"})," has an ",(0,t.jsx)(e.code,{children:"Engine"}),", but the ",(0,t.jsx)(e.code,{children:"Engine"})," can exist separately from the ",(0,t.jsx)(e.code,{children:"Car"}),"."]}),"\n",(0,t.jsx)(e.h4,{id:"2-example-of-aggregation-in-java",children:(0,t.jsx)(e.strong,{children:"2. Example of Aggregation in Java"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Aggregation Example: Driver and Car\nclass Car {\n    String model;\n    \n    Car(String model) {\n        this.model = model;\n    }\n}\n\nclass Driver {\n    String name;\n    Car car; // Aggregation: Driver has a Car\n    \n    Driver(String name, Car car) {\n        this.name = name;\n        this.car = car;\n    }\n    \n    void showDetails() {\n        System.out.println(name + " is driving " + car.model);\n    }\n}\n\npublic class AggregationExample {\n    public static void main(String[] args) {\n        Car car1 = new Car("Tesla Model S");\n        Driver driver1 = new Driver("John", car1);\n        driver1.showDetails();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"3-explanation-of-aggregation-code",children:(0,t.jsx)(e.strong,{children:"3. Explanation of Aggregation Code"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Driver"})," and ",(0,t.jsx)(e.code,{children:"Car"}),' have a "has-a" relationship.']}),"\n",(0,t.jsxs)(e.li,{children:["The ",(0,t.jsx)(e.code,{children:"Car"})," object can exist independently of the ",(0,t.jsx)(e.code,{children:"Driver"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["The ",(0,t.jsx)(e.code,{children:"Driver"})," object contains a reference to the ",(0,t.jsx)(e.code,{children:"Car"})," object, representing a loose coupling."]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h4,{id:"4-what-is-composition",children:(0,t.jsx)(e.strong,{children:"4. What is Composition?"})}),"\n",(0,t.jsxs)(e.p,{children:["Composition is a stronger form of aggregation where the contained object cannot exist independently. When the parent object is created or destroyed, the child object is also created or destroyed. For example, an ",(0,t.jsx)(e.code,{children:"Engine"})," is an essential part of a ",(0,t.jsx)(e.code,{children:"Vehicle"}),", and if the ",(0,t.jsx)(e.code,{children:"Vehicle"})," is destroyed, the ",(0,t.jsx)(e.code,{children:"Engine"})," is destroyed too."]}),"\n",(0,t.jsx)(e.h4,{id:"5-example-of-composition-in-java",children:(0,t.jsx)(e.strong,{children:"5. Example of Composition in Java"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Composition Example: Vehicle and Engine\nclass Engine {\n    Engine() {\n        System.out.println("Engine created");\n    }\n    void start() {\n        System.out.println("Engine started");\n    }\n}\n\nclass Vehicle {\n    private final Engine engine; // Composition: Vehicle has an Engine\n    \n    Vehicle() {\n        engine = new Engine(); // Engine is created with Vehicle\n    }\n    \n    void startVehicle() {\n        engine.start();\n        System.out.println("Vehicle is running");\n    }\n}\n\npublic class CompositionExample {\n    public static void main(String[] args) {\n        Vehicle vehicle = new Vehicle();\n        vehicle.startVehicle();\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"6-explanation-of-composition-code",children:(0,t.jsx)(e.strong,{children:"6. Explanation of Composition Code"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Vehicle"})," and ",(0,t.jsx)(e.code,{children:"Engine"}),' have a strong "has-a" relationship.']}),"\n",(0,t.jsxs)(e.li,{children:["The ",(0,t.jsx)(e.code,{children:"Engine"})," is part of the ",(0,t.jsx)(e.code,{children:"Vehicle"})," and is created inside it."]}),"\n",(0,t.jsxs)(e.li,{children:["When the ",(0,t.jsx)(e.code,{children:"Vehicle"})," is destroyed, the ",(0,t.jsx)(e.code,{children:"Engine"})," is also destroyed."]}),"\n",(0,t.jsxs)(e.li,{children:["The ",(0,t.jsx)(e.code,{children:"Engine"})," cannot exist independently of the ",(0,t.jsx)(e.code,{children:"Vehicle"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h3,{id:"7-differences-between-aggregation-and-composition",children:(0,t.jsx)(e.strong,{children:"7. Differences Between Aggregation and Composition"})}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Feature"}),(0,t.jsx)(e.th,{children:"Aggregation"}),(0,t.jsx)(e.th,{children:"Composition"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Relationship Type"}),(0,t.jsx)(e.td,{children:"Loosely Coupled"}),(0,t.jsx)(e.td,{children:"Strongly Coupled"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Object Dependency"}),(0,t.jsx)(e.td,{children:"Child object can exist independently"}),(0,t.jsx)(e.td,{children:"Child object cannot exist independently"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Example"}),(0,t.jsx)(e.td,{children:"Driver and Car"}),(0,t.jsx)(e.td,{children:"Vehicle and Engine"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Lifecycle"}),(0,t.jsx)(e.td,{children:"Parent and child have independent lifecycles"}),(0,t.jsx)(e.td,{children:"Child depends on the parent\u2019s lifecycle"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"8-conclusion",children:(0,t.jsx)(e.strong,{children:"8. Conclusion"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Aggregation"})," allows objects to have independent existence while being associated."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Composition"})," creates a stronger dependency, ensuring that the child object only exists within the parent."]}),"\n",(0,t.jsx)(e.li,{children:"Both concepts help in designing flexible and maintainable object-oriented applications."}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://github.com/user-attachments/assets/e95ef50e-73b1-46db-bd61-c8d6c3692136",alt:"image"})}),"\n",(0,t.jsx)(e.h3,{id:"understanding-java-program-execution-jvm-static-and-non-static-elements",children:(0,t.jsx)(e.strong,{children:"Understanding Java Program Execution: JVM, Static, and Non-Static Elements"})}),"\n",(0,t.jsx)(e.h4,{id:"1-how-java-program-execution-starts",children:(0,t.jsx)(e.strong,{children:"1. How Java Program Execution Starts"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["The execution starts when the ",(0,t.jsx)(e.strong,{children:"Operating System (OS)"})," sends control to the ",(0,t.jsx)(e.strong,{children:"Java Virtual Machine (JVM)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["The JVM loads the main class and passes control to the ",(0,t.jsx)(e.strong,{children:"Class Loader"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["The ",(0,t.jsx)(e.strong,{children:"Class Loader"})," loads the class and initializes:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Static variables"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Static methods"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Static blocks"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["The control is then passed back to the JVM, which:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Allocates memory for static variables."}),"\n",(0,t.jsx)(e.li,{children:"Executes static blocks."}),"\n",(0,t.jsxs)(e.li,{children:["Executes the ",(0,t.jsx)(e.code,{children:"main()"})," method."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"2-rules-for-static-and-non-static-elements",children:(0,t.jsx)(e.strong,{children:"2. Rules for Static and Non-Static Elements"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static variables"})," can be accessed inside static blocks, static methods, non-static methods, and constructors."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Non-static variables"})," can only be accessed inside non-static blocks, non-static methods, and constructors."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Non-static blocks"})," are executed before the constructor when an object is created."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Constructors"})," are executed after non-static blocks during object creation."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static methods"})," belong to the class and can be accessed without creating an object."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Non-static methods"})," require an object instance to be accessed."]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"3-java-program-demonstrating-static-and-non-static-elements",children:(0,t.jsx)(e.strong,{children:"3. Java Program Demonstrating Static and Non-Static Elements"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Main class\npublic class Main {\n    public static void main(String[] args) {\n        // Calling static method without object creation\n        Program.display1(); \n        \n        // Creating an object of Program class\n        Program p = new Program();\n        \n        // Calling non-static method using object reference\n        p.display2();\n    }\n}\n\n// Program class\nclass Program {\n    // Static variables\n    static int a, b;\n    \n    // Static block - executes once when class is loaded\n    static {\n        System.out.println("Inside static block");\n        a = 10;\n        b = 20;\n    }\n    \n    // Static method\n    static void display1() {\n        System.out.println("Inside static method display1()");\n        System.out.println(a);\n        System.out.println(b);\n    }\n    \n    // Instance variables (Non-static variables)\n    int x, y;\n    \n    // Non-static block - executes before constructor when object is created\n    {\n        System.out.println("Inside non-static block");\n        a = 100;\n        b = 200;\n        x = 300;\n        y = 400;\n    }\n    \n    // Non-static method\n    void display2() {\n        System.out.println("Inside non-static method display2()");\n        System.out.println(a);\n        System.out.println(b);\n        System.out.println(x);\n        System.out.println(y);\n    }\n    \n    // Constructor\n    Program() {\n        System.out.println("Inside constructor");\n        a = 1000;\n        b = 2000;\n        x = 3000;\n        y = 4000;\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h4,{id:"4-explanation-of-the-code",children:(0,t.jsx)(e.strong,{children:"4. Explanation of the Code"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static Block:"})," Executes once when the class is loaded and initializes static variables."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Static Method:"})," Can be called without an object and prints static variables."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Non-Static Block:"})," Executes before the constructor and initializes instance variables."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Constructor:"})," Runs after the non-static block when an object is created."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[(0,t.jsx)(e.code,{children:"display1()"})," (Static Method):"]})," Prints static variables."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[(0,t.jsx)(e.code,{children:"display2()"})," (Non-Static Method):"]})," Prints both static and instance variables."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Main Method Execution:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["Calls ",(0,t.jsx)(e.code,{children:"display1()"})," before creating an object."]}),"\n",(0,t.jsxs)(e.li,{children:["Creates an object of ",(0,t.jsx)(e.code,{children:"Program"}),", triggering the non-static block and constructor."]}),"\n",(0,t.jsxs)(e.li,{children:["Calls ",(0,t.jsx)(e.code,{children:"display2()"})," to access instance variables."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"5-summary",children:(0,t.jsx)(e.strong,{children:"5. Summary"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.strong,{children:["JVM executes static blocks, variables, and methods before calling the ",(0,t.jsx)(e.code,{children:"main()"})," method."]})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Static elements are associated with the class, while non-static elements are associated with an object instance."})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Static methods can be called without an object, while non-static methods require an object."})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Non-static blocks run before the constructor during object creation."})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Understanding the execution flow helps in designing efficient Java applications."})}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"public class Main{\n    public static void main(String[] args) {\n         // static variables\n         // non-static variables (instance variables)\n \n         // static methods\n         // non-static methods (instance methods)\n \n         // static blocks\n         // non-static blocks (instance blocks)\n \n         // constructors\n    }\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// Professional class\nclass Professional {\n    private static String universityName = "Global University";\n    private static int totalProfessors = 0;\n    \n    private int professorID;\n    private String subject;\n    \n    // Static block\n    static {\n        System.out.println("Welcome to " + universityName);\n    }\n    \n    // Non-static block\n    {\n        totalProfessors++;\n        professorID = totalProfessors;\n    }\n    \n    // Constructor\n    public Professional(String subject) {\n        this.subject = subject;\n    }\n    \n    // Method to display professor details\n    public void displayDetails() {\n        System.out.println("Professor ID: " + professorID + ", Subject: " + subject);\n    }\n    \n    // Static method to get total number of professors\n    public static int getTotalProfessors() {\n        return totalProfessors;\n    }\n    \n    public static void main(String[] args) {\n        // Creating instances of Professional class\n        Professional prof1 = new Professional("Mathematics");\n        Professional prof2 = new Professional("Physics");\n        \n        // Displaying details\n        prof1.displayDetails();\n        prof2.displayDetails();\n        \n        // Displaying total number of professors\n        System.out.println("Total Professors: " + Professional.getTotalProfessors());\n    }\n}\n\n'})})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,s){s.d(e,{R:()=>o,x:()=>a});var i=s(6540);const t={},r=i.createContext(t);function o(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);
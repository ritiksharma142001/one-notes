"use strict";(self.webpackChunkes_note=self.webpackChunkes_note||[]).push([[7101],{28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var t=i(96540);const o={},r=t.createContext(o);function s(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),t.createElement(r.Provider,{value:e},n.children)}},89791:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core-java/Collections/advance","title":"advance","description":"Notes on Structural Modification and Concurrent Modification in Java","source":"@site/docs/core-java/Collections/advance.md","sourceDirName":"core-java/Collections","slug":"/core-java/Collections/advance","permalink":"/one-notes/core-java/Collections/advance","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/core-java/Collections/advance.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"3","permalink":"/one-notes/core-java/Collections/3"},"next":{"title":"Java Collections and Algorithms","permalink":"/one-notes/core-java/Collections/"}}');var o=i(74848),r=i(28453);const s={sidebar_position:4},a=void 0,l={},c=[{value:"<strong>Introduction</strong>",id:"introduction",level:2},{value:"<strong>1. Structural Modification</strong>",id:"1-structural-modification",level:2},{value:"<strong>Example of Structural Modification (Infinite Loop Issue)</strong>",id:"example-of-structural-modification-infinite-loop-issue",level:3},{value:"<strong>2. Concurrent Modification</strong>",id:"2-concurrent-modification",level:2},{value:"<strong>Example of Concurrent Modification Exception</strong>",id:"example-of-concurrent-modification-exception",level:3},{value:"<strong>3. Safe Modification Using Iterator</strong>",id:"3-safe-modification-using-iterator",level:2},{value:"<strong>Example of Safe Removal Using Iterator</strong>",id:"example-of-safe-removal-using-iterator",level:3},{value:"<strong>Key Takeaways</strong>",id:"key-takeaways",level:2},{value:"Introduction",id:"introduction-1",level:3},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Issues with Different Iteration Methods",id:"issues-with-different-iteration-methods",level:3},{value:"Example: Using <code>CopyOnWriteArrayList</code>",id:"example-using-copyonwritearraylist",level:3},{value:"Explanation of the Code",id:"explanation-of-the-code",level:3},{value:"Summary",id:"summary",level:3}];function d(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Notes on Structural Modification and Concurrent Modification in Java"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:(0,o.jsx)(e.strong,{children:"Introduction"})}),"\n",(0,o.jsxs)(e.p,{children:["In Java, modifying a collection while iterating over it can lead to unexpected behavior or exceptions. Understanding ",(0,o.jsx)(e.strong,{children:"structural modification"})," and ",(0,o.jsx)(e.strong,{children:"concurrent modification"})," is essential for writing robust code."]}),"\n",(0,o.jsx)(e.h2,{id:"1-structural-modification",children:(0,o.jsx)(e.strong,{children:"1. Structural Modification"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Structural modification occurs when elements are ",(0,o.jsx)(e.strong,{children:"added or removed"})," from a collection."]}),"\n",(0,o.jsxs)(e.li,{children:["Using an ",(0,o.jsx)(e.strong,{children:"index-based for loop"})," while modifying the collection can lead to ",(0,o.jsx)(e.strong,{children:"infinite loops"})," or ",(0,o.jsx)(e.strong,{children:"unexpected behavior"}),"."]}),"\n",(0,o.jsx)(e.li,{children:"The loop counter does not adjust dynamically to the changes in collection size, causing logical errors."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"example-of-structural-modification-infinite-loop-issue",children:(0,o.jsx)(e.strong,{children:"Example of Structural Modification (Infinite Loop Issue)"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-java",children:'List<Integer> list = new ArrayList<>();\nfor (int i = 0; i < 5; i++) {\n    list.add(i * 10); // Adds: 0, 10, 20, 30, 40\n}\n\nfor (int i = 0; i < list.size(); i++) {\n    if (list.get(i) == 20) {\n        list.add(60); // Modifying list while iterating\n    }\n    System.out.println("Current List: " + list);\n}\n'})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Issue:"})," The list grows dynamically, causing an ",(0,o.jsx)(e.strong,{children:"infinite loop"}),"."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"2-concurrent-modification",children:(0,o.jsx)(e.strong,{children:"2. Concurrent Modification"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Java provides a ",(0,o.jsx)(e.strong,{children:"fail-fast mechanism"})," that throws a ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"})," if a collection is modified while being iterated using an ",(0,o.jsx)(e.strong,{children:"enhanced for-loop"})," or ",(0,o.jsx)(e.strong,{children:"Iterator"}),"."]}),"\n",(0,o.jsx)(e.li,{children:"This prevents inconsistent data access and ensures thread safety."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"example-of-concurrent-modification-exception",children:(0,o.jsx)(e.strong,{children:"Example of Concurrent Modification Exception"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-java",children:"for (Integer num : list) {\n    if (num == 30) {\n        list.add(70); // Attempting modification during iteration\n    }\n    System.out.println(num);\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Issue:"})," This results in a ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"})," since the ",(0,o.jsx)(e.strong,{children:"enhanced for-loop"})," does not allow modification during iteration."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"3-safe-modification-using-iterator",children:(0,o.jsx)(e.strong,{children:"3. Safe Modification Using Iterator"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["To safely remove elements while iterating, use an ",(0,o.jsx)(e.strong,{children:"Iterator"}),"."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"iterator.remove()"})," ensures safe modification without triggering exceptions."]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"example-of-safe-removal-using-iterator",children:(0,o.jsx)(e.strong,{children:"Example of Safe Removal Using Iterator"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-java",children:"Iterator<Integer> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    int num = iterator.next();\n    if (num == 40) {\n        iterator.remove(); // Safe removal\n    }\n    System.out.println(num);\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solution:"})," Using an Iterator allows ",(0,o.jsx)(e.strong,{children:"safe element removal"}),", avoiding ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"}),"."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-takeaways",children:(0,o.jsx)(e.strong,{children:"Key Takeaways"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Structural modification"})," inside an index-based loop can cause ",(0,o.jsx)(e.strong,{children:"infinite loops"}),"."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Concurrent modification"})," inside an enhanced for-loop or Iterator ",(0,o.jsx)(e.strong,{children:"throws exceptions"}),"."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Use an Iterator"})," (",(0,o.jsx)(e.code,{children:"iterator.remove()"}),") when removing elements to prevent runtime errors."]}),"\n",(0,o.jsxs)(e.li,{children:["Java's ",(0,o.jsx)(e.strong,{children:"fail-fast mechanism"})," helps prevent unintended modifications and ensures data consistency."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"By following these best practices, you can safely modify Java collections without encountering errors or infinite loops."}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Notes on Structural Modification and Concurrent Modification in Java"})}),"\n",(0,o.jsx)(e.h3,{id:"introduction-1",children:"Introduction"}),"\n",(0,o.jsxs)(e.p,{children:["Structural modification in Java occurs when elements are added or removed from a collection while iterating over it. This can lead to ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"})," when using certain iterators. Java provides different mechanisms to handle such scenarios, including fail-fast and fail-safe iterators."]}),"\n",(0,o.jsx)(e.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Structural Modification"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Refers to adding or removing elements from a collection during iteration."}),"\n",(0,o.jsx)(e.li,{children:"Can lead to infinite loops or exceptions if not handled properly."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Fail-Fast vs Fail-Safe Iterators"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fail-Fast Iterators:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Throw ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"})," when a structural modification occurs."]}),"\n",(0,o.jsxs)(e.li,{children:["Used in collections from ",(0,o.jsx)(e.code,{children:"java.util"})," package (e.g., ",(0,o.jsx)(e.code,{children:"ArrayList"}),", ",(0,o.jsx)(e.code,{children:"HashMap"}),")."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fail-Safe Iterators:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Work on a cloned copy of the collection, preventing ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"}),"."]}),"\n",(0,o.jsxs)(e.li,{children:["Used in concurrent collections like ",(0,o.jsx)(e.code,{children:"CopyOnWriteArrayList"})," from ",(0,o.jsx)(e.code,{children:"java.util.concurrent"})," package."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"issues-with-different-iteration-methods",children:"Issues with Different Iteration Methods"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"For Loop (Index-Based)"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Can lead to an ",(0,o.jsx)(e.strong,{children:"infinite loop"})," if elements are added dynamically because the index is continuously incrementing while new elements are inserted."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Enhanced For Loop (For-Each Loop)"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Cannot handle concurrent modification as it does not use an explicit iterator."}),"\n",(0,o.jsxs)(e.li,{children:["Throws ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"})," if structural modification occurs."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Using an Iterator"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Standard iterators in ",(0,o.jsx)(e.code,{children:"java.util"})," collections will fail-fast and throw ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"}),"."]}),"\n",(0,o.jsxs)(e.li,{children:["Iterators in fail-safe collections like ",(0,o.jsx)(e.code,{children:"CopyOnWriteArrayList"})," allow modifications as they work on a cloned copy of the list."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.h3,{id:"example-using-copyonwritearraylist",children:["Example: Using ",(0,o.jsx)(e.code,{children:"CopyOnWriteArrayList"})]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"CopyOnWriteArrayList"})," is a thread-safe variant of ",(0,o.jsx)(e.code,{children:"ArrayList"}),". It allows structural modification during iteration by working on a copy of the original list."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-java",children:"import java.util.Iterator;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Creating a CopyOnWriteArrayList instance\n        CopyOnWriteArrayList<Integer> cwal = new CopyOnWriteArrayList<>();\n        cwal.add(10);\n        cwal.add(20);\n        cwal.add(30);\n        cwal.add(40);\n\n        int count = 60;\n\n        // Using an iterator to traverse the list\n        Iterator<Integer> iterator = cwal.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n            cwal.add(count); // Modifying the list during iteration\n            count += 10;\n        }\n    }\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"explanation-of-the-code",children:"Explanation of the Code"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["A ",(0,o.jsx)(e.code,{children:"CopyOnWriteArrayList"})," is created and initialized with some values."]}),"\n",(0,o.jsx)(e.li,{children:"An iterator is used to traverse the list."}),"\n",(0,o.jsx)(e.li,{children:"While iterating, new elements are added to the list."}),"\n",(0,o.jsxs)(e.li,{children:["The iteration does not fail because ",(0,o.jsx)(e.code,{children:"CopyOnWriteArrayList"})," uses a copy of the original list for iteration, making it ",(0,o.jsx)(e.strong,{children:"fail-safe"}),"."]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fail-Fast iterators"})," (used in ",(0,o.jsx)(e.code,{children:"java.util"})," collections) throw ",(0,o.jsx)(e.code,{children:"ConcurrentModificationException"})," if a structural modification occurs."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Fail-Safe iterators"})," (used in ",(0,o.jsx)(e.code,{children:"java.util.concurrent"})," collections) work on a copy of the list, allowing modifications during iteration."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"CopyOnWriteArrayList"})," is a thread-safe alternative to ",(0,o.jsx)(e.code,{children:"ArrayList"})," when modifications need to be made during iteration."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Understanding these concepts is crucial for handling concurrent modifications efficiently in Java applications."})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);
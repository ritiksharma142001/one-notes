"use strict";(self.webpackChunkes_note=self.webpackChunkes_note||[]).push([[1572],{14299:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/11-39fd6418e0f6188149ffc5ca565369bc.png"},16736:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/12-58c2ba80b5f955ab19527769742371b9.png"},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>d});var i=s(96540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}},40937:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/13-9e46ad9639ed658caa6678c9ad1d94f6.png"},41400:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/9-5c107ac8ee324d438692305f5dc761cf.png"},43630:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"advanced-java/1-100/Week-5/5.2","title":"Apache Kafka Architecture","description":"1","source":"@site/docs/advanced-java/1-100/Week-5/5.2.md","sourceDirName":"advanced-java/1-100/Week-5","slug":"/advanced-java/1-100/Week-5/5.2","permalink":"/one-notes/advanced-java/1-100/Week-5/5.2","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/advanced-java/1-100/Week-5/5.2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Kafka","permalink":"/one-notes/advanced-java/1-100/Week-5/5.1"},"next":{"title":"Installing Kafka","permalink":"/one-notes/advanced-java/1-100/Week-5/5.3"}}');var r=s(74848),t=s(28453);const a={sidebar_position:2},d="Apache Kafka Architecture",l={},o=[{value:"Interview Questions",id:"interview-questions",level:2},{value:"Partitioning Logic",id:"partitioning-logic",level:2},{value:"Partition Assignment Logic",id:"partition-assignment-logic",level:2},{value:"Why Multiple Users Can Go to the Same Partition",id:"why-multiple-users-can-go-to-the-same-partition",level:2},{value:"Reading records from Partitions",id:"reading-records-from-partitions",level:2},{value:"Consumer Groups",id:"consumer-groups",level:2},{value:"Rebalancing",id:"rebalancing",level:2},{value:"Partition Replication",id:"partition-replication",level:2},{value:"Partition Management",id:"partition-management",level:2},{value:"Kafka Log Retention",id:"kafka-log-retention",level:2},{value:"Acks and Retries",id:"acks-and-retries",level:2}];function c(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"apache-kafka-architecture",children:"Apache Kafka Architecture"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"1",src:s(47184).A+"",width:"724",height:"242"})}),"\n",(0,r.jsx)(n.h2,{id:"interview-questions",children:"Interview Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"How does the Partitioning of Topics take place?"}),"\n",(0,r.jsx)(n.li,{children:"How does Kafka ensure message ordering?"}),"\n",(0,r.jsx)(n.li,{children:"Can the consumers read the same message again and again?"}),"\n",(0,r.jsx)(n.li,{children:"What happens when new Consumers are added to the system?"}),"\n",(0,r.jsx)(n.li,{children:"What happens when some brokers go down?"}),"\n",(0,r.jsx)(n.li,{children:"Can consumer read the messages after a few days they are produced?"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"partitioning-logic",children:"Partitioning Logic"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kafka splits data into partitions to improve scalability and parallelism. Each topic in Kafka has one or more partitions."}),"\n",(0,r.jsx)(n.li,{children:"A producer is a client that sends data (messages/records) to a Kafka topic."}),"\n",(0,r.jsxs)(n.li,{children:["When a producer sends a message, it can optionally include a ",(0,r.jsx)(n.strong,{children:"partition key"})," (e.g., user ID, device ID).","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kafka uses this key to decide which partition to send the message to."}),"\n",(0,r.jsx)(n.li,{children:"All messages with the same key go to the same partition."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Example: If you use ",(0,r.jsx)(n.strong,{children:"user123"})," as the key, all messages for ",(0,r.jsx)(n.strong,{children:"user123"})," will always go to the same partition, and consumers will get them in the correct order."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What happens if no partition key is used?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kafka automatically distributes the messages across partitions using round-robin (takes turns)."}),"\n",(0,r.jsx)(n.li,{children:"This means: Message 1 \u2192 Partition A, Message 2 \u2192 Partition B, Message 3 \u2192 Partition C, and so on."}),"\n",(0,r.jsx)(n.li,{children:"But: Because there's no fixed key, messages from the same source may end up in different partitions, so the order of messages is not guaranteed."}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"With Partition Key"}),(0,r.jsx)(n.th,{children:"Without Partition Key"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Same key \u2192 same partition"}),(0,r.jsx)(n.td,{children:"Round-robin distribution"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Order is preserved"}),(0,r.jsxs)(n.td,{children:["Order ",(0,r.jsx)(n.strong,{children:"not guaranteed"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Useful for user/device-specific data"}),(0,r.jsx)(n.td,{children:"Good for load balancing"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"partition key",src:s(61003).A+"",width:"722",height:"187"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Understanding",src:s(41400).A+"",width:"1692",height:"779"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Users:\nU101 - Login, ClickAd\nU102 - Login, AddToCart\nU103 - Search, Logout\nU104 - ViewProduct\nU105 - AddToCart, BuyNow\nU106 - ClickAd, Logout\n\n--\x3e Producer sends to Kafka with key=userId\n\nTopics & Partitions:\nt0: P0, P1, P2       \u2190 U101, U102, U103\nt1: P0, P1           \u2190 U104, U105, U106\n\nConsumer Group-A (t0):\n- C1 reads P0, P1 \u2192 gets U103, U101\n- C2 reads P2     \u2192 gets U102\n\nConsumer Group-B (t1):\n- C3 reads P0     \u2192 gets U105\n- C4 reads P1     \u2192 gets U104, U106\n- C5 unassigned   \u2192 idle\n\n"})}),"\n",(0,r.jsx)(n.h2,{id:"partition-assignment-logic",children:"Partition Assignment Logic"}),"\n",(0,r.jsxs)(n.p,{children:["In Kafka, partition assignment is based on the ",(0,r.jsx)(n.strong,{children:"message key"})," (e.g., ",(0,r.jsx)(n.code,{children:"userId"}),") and a ",(0,r.jsx)(n.strong,{children:"hashing function"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"partition = hash(key) % number_of_partitions\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So, if two different user IDs result in the same hash modulo, they\u2019ll be assigned to the ",(0,r.jsx)(n.strong,{children:"same partition"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Example: 3 Partitions in Topic ",(0,r.jsx)(n.code,{children:"t0"})]})}),"\n",(0,r.jsx)(n.p,{children:"Users\nU101, U102, U103, U104, U105, U106"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Kafka Applies Hash Like:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"User ID"}),(0,r.jsx)(n.th,{children:"Hash (simplified)"}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"hash % 3"})}),(0,r.jsx)(n.th,{children:"Assigned Partition"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"U101"}),(0,r.jsx)(n.td,{children:"101"}),(0,r.jsx)(n.td,{children:"101 % 3 = 2"}),(0,r.jsx)(n.td,{children:"P2"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"U102"}),(0,r.jsx)(n.td,{children:"102"}),(0,r.jsx)(n.td,{children:"102 % 3 = 0"}),(0,r.jsx)(n.td,{children:"P0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"U103"}),(0,r.jsx)(n.td,{children:"103"}),(0,r.jsx)(n.td,{children:"103 % 3 = 1"}),(0,r.jsx)(n.td,{children:"P1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"U104"}),(0,r.jsx)(n.td,{children:"104"}),(0,r.jsx)(n.td,{children:"104 % 3 = 2"}),(0,r.jsx)(n.td,{children:"P2"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"U105"}),(0,r.jsx)(n.td,{children:"105"}),(0,r.jsx)(n.td,{children:"105 % 3 = 0"}),(0,r.jsx)(n.td,{children:"P0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"U106"}),(0,r.jsx)(n.td,{children:"106"}),(0,r.jsx)(n.td,{children:"106 % 3 = 1"}),(0,r.jsx)(n.td,{children:"P1"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Result:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Partition"}),(0,r.jsx)(n.th,{children:"Assigned Users"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"P0"}),(0,r.jsx)(n.td,{children:"U102, U105"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"P1"}),(0,r.jsx)(n.td,{children:"U103, U106"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"P2"}),(0,r.jsx)(n.td,{children:"U101, U104"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"why-multiple-users-can-go-to-the-same-partition",children:"Why Multiple Users Can Go to the Same Partition"}),"\n",(0,r.jsxs)(n.p,{children:["Kafka's partition assignment is ",(0,r.jsx)(n.strong,{children:"deterministic"})," but ",(0,r.jsx)(n.strong,{children:"not unique per user"}),". If multiple keys (users) happen to map to the same partition via the hash function, they will ",(0,r.jsx)(n.strong,{children:"share that partition"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Kafka does ",(0,r.jsx)(n.strong,{children:"not guarantee one partition per user"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Points to Remember"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Concept"}),(0,r.jsx)(n.th,{children:"Explanation"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"key"})}),(0,r.jsxs)(n.td,{children:["Message key (e.g., ",(0,r.jsx)(n.code,{children:"userId"}),") is used for consistent routing"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"hash(key) % N"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"N"})," is the number of partitions; this determines partition assignment"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Same partition"}),(0,r.jsxs)(n.td,{children:["Multiple keys can land in the same partition if their ",(0,r.jsx)(n.code,{children:"hash % N"})," is equal"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Consumer assignment"}),(0,r.jsxs)(n.td,{children:["Kafka assigns each partition to ",(0,r.jsx)(n.strong,{children:"only one consumer per consumer group"})]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Order guarantee"}),(0,r.jsxs)(n.td,{children:["Kafka guarantees order ",(0,r.jsx)(n.strong,{children:"only within a partition"}),", not across partitions"]})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Real World Usage"})}),"\n",(0,r.jsxs)(n.p,{children:["This behavior is often ",(0,r.jsx)(n.strong,{children:"intentional"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If you want ",(0,r.jsx)(n.strong,{children:"user-related events"})," to stay together, you use the same ",(0,r.jsx)(n.strong,{children:"message key"})," (",(0,r.jsx)(n.code,{children:"userId"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Kafka is fine with ",(0,r.jsx)(n.strong,{children:"multiple users falling into the same partition"})]}),"\n",(0,r.jsxs)(n.li,{children:["What matters is that ",(0,r.jsx)(n.strong,{children:"message order per user is preserved"})," if they\u2019re consistently routed"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"reading-records-from-partitions",children:"Reading records from Partitions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Unlike the other pub/sub implementations, Kafka doesn't push messages to consumers. Instead, consumers have to pull messages off Kafka topic partitions. A consumer connects to a partition in a broker, reads the messages in the order in which they were written."}),"\n",(0,r.jsxs)(n.li,{children:["By remembering the offset of the last consumed message for each partition, a consumer can join a partition at the point in time they choose and resume from there. That is particularly useful for a consumer to resume reading after recovering from a crash.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Imagine you're reading a book (Kafka topic) with chapters (partitions). Each page (message) has a number (offset)."}),"\n",(0,r.jsx)(n.li,{children:"If you close the book at page 42 (offset 42), when you come back, you want to resume from page 43 \u2014 not from the beginning."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"But this may create a problem where multiple consumers instances of the same type read the record of a Kafka topic. To avoid this, Kafka has a concept called Consumer Groups."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:s(92754).A+"",width:"1664",height:"671"})}),"\n",(0,r.jsx)(n.h2,{id:"consumer-groups",children:"Consumer Groups"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:s(14299).A+"",width:"1238",height:"606"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A Consumer Group is a collection of Kafka consumers working together to read data from a topic. Kafka ensures:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each partition of a topic is read by only one consumer in the group."}),"\n",(0,r.jsx)(n.li,{children:"But multiple consumers can read from different partitions in parallel."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["One partition is assigned to only one consumer in a group.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This avoids duplication: no two consumers in the same group will read the same message."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Kafka does not increase parallelism just because you add more consumers.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If a topic has 3 partitions, maximum 3 consumers in a group can read in parallel."}),"\n",(0,r.jsx)(n.li,{children:"If you add more consumers (say 5), 2 of them will sit idle, because only 3 partitions are available."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Think of partitions as machines, and consumers as workers.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If there are 3 machines and 5 workers, only 3 workers can operate."}),"\n",(0,r.jsx)(n.li,{children:"The other 2 workers have nothing to do unless a machine is added."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Consumer Group: CG1"}),(0,r.jsx)(n.th,{children:"Partitions"}),(0,r.jsx)(n.th,{children:"Status"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"C1"}),(0,r.jsx)(n.td,{children:"P0"}),(0,r.jsx)(n.td,{children:"Active"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"C2"}),(0,r.jsx)(n.td,{children:"P1"}),(0,r.jsx)(n.td,{children:"Active"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"C3"}),(0,r.jsx)(n.td,{children:"P2"}),(0,r.jsx)(n.td,{children:"Active"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"C4"}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Idle"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"C5"}),(0,r.jsx)(n.td,{children:"-"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Idle"})})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://softwaremill.com/kafka-visualisation/",children:"Kafka Visualization Tools"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"rebalancing",children:"Rebalancing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rebalancing is the process of reassigning partitions to consumers within a consumer group, ensuring that the workload is evenly distributed."}),"\n",(0,r.jsx)(n.li,{children:"Rebalancing is triggered when:"}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Scenario"}),(0,r.jsx)(n.th,{children:"What Happens"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"A new consumer joins"}),(0,r.jsx)(n.td,{children:"Kafka redistributes partitions to include the new consumer"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"A consumer leaves or crashes"}),(0,r.jsx)(n.td,{children:"Kafka reassigns that consumer's partitions to remaining consumers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"New partitions are added"}),(0,r.jsx)(n.td,{children:"Kafka balances the increased partitions among all active consumers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"A consumer is declared dead"}),(0,r.jsx)(n.td,{children:"The coordinator reassigns its partitions to others"})]})]})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The first consumer to join a consumer group is called the Group Leader."}),"\n",(0,r.jsx)(n.li,{children:"The Group Leader helps the Kafka Group Coordinator decide which consumer should get which partition during rebalancing."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Topic:"})," t0 with 3 partitions: P0, P1, P2",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.strong,{children:"Initial consumers in group:"})," C1, C2"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"efore Rebalancing"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"C1 \u2192 P0, P1  \nC2 \u2192 P2\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now, C3 joins the group. A rebalance happens.\nAfter Rebalancing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"C1 \u2192 P0  \nC2 \u2192 P1  \nC3 \u2192 P2\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now each consumer has one partition, so the load is evenly distributed."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"partition-replication",children:"Partition Replication"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:s(16736).A+"",width:"742",height:"405"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Replication in Kafka means creating copies of a partition and storing them on multiple brokers. This ensures fault tolerance and high availability of data."}),"\n",(0,r.jsxs)(n.li,{children:["For each partition:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"One replica is elected as the leader."}),"\n",(0,r.jsx)(n.li,{children:"The remaining replicas are followers."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"All read and write requests for that partition go through the leader. Followers replicate the leader's data and stay in sync."}),"\n",(0,r.jsx)(n.li,{children:"If the leader broker fails, one of the followers is automatically promoted to become the new leader, ensuring no data loss and continued availability."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"partition-management",children:"Partition Management"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"gf",src:s(40937).A+"",width:"604",height:"279"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Kafka Brokers, Replication, and KRaft Mode"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"In a Kafka cluster:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Partitions are replicated across multiple brokers for fault tolerance."}),"\n",(0,r.jsx)(n.li,{children:"Each partition has one leader broker, and the others hold follower replicas."}),"\n",(0,r.jsx)(n.li,{children:"All client interactions (reads/writes) go through the leader of each partition."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"To coordinate this setup, Kafka needs a way to manage metadata and broker state."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Transition from ZooKeeper to KRaft"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Historically, Kafka used ZooKeeper for:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tracking brokers, topics, and partitions."}),"\n",(0,r.jsx)(n.li,{children:"Managing leader election and metadata."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"However, Kafka is moving towards a ZooKeeper-free architecture with the introduction of the KRaft (Kafka Raft) mode, which:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses the Raft consensus protocol."}),"\n",(0,r.jsx)(n.li,{children:"Allows Kafka brokers to coordinate directly with each other."}),"\n",(0,r.jsx)(n.li,{children:"Elects a controller leader among brokers."}),"\n",(0,r.jsx)(n.li,{children:"Replicates metadata logs across all brokers."}),"\n",(0,r.jsx)(n.li,{children:"Increases reliability, simplifies operations, and improves performance.\nKRaft mode effectively eliminates the need for ZooKeeper, making Kafka more self-contained and cloud-native."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"kafka-log-retention",children:"Kafka Log Retention"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Kafka's log retention controls how long messages are kept in a topic. Messages are\nstored on disk, and Kafka can retain them based on time (retention.ms) or size\n(retention.bytes), whichever comes first. Once the retention limit is reached, old\nmessages are deleted in the background. Kafka can also be configured to retain\nmessages indefinitely (retention.ms=-1), but this could lead to high storage costs if\nnot managed carefully."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"acks-and-retries",children:"Acks and Retries"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Kafka Producer Acknowledgments (acks)"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"acks"})," configuration determines the number of acknowledgments the producer requires from the broker before considering a request complete. It has three possible settings: ",(0,r.jsx)(n.code,{children:"0"}),", ",(0,r.jsx)(n.code,{children:"1"}),", and ",(0,r.jsx)(n.code,{children:"all (-1)"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Possible Values:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"acks = 0"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The producer does ",(0,r.jsx)(n.strong,{children:"not"})," wait for any acknowledgment from the broker."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fastest"})," option, but provides ",(0,r.jsx)(n.strong,{children:"no guarantee"})," that the message has been received or written to the broker."]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"acks = 1"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The producer will receive an acknowledgment as soon as the ",(0,r.jsx)(n.strong,{children:"leader broker"})," has received the message."]}),"\n",(0,r.jsxs)(n.li,{children:["Provides ",(0,r.jsx)(n.strong,{children:"some assurance"})," that the message is stored on the leader broker."]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"acks = all (-1)"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The producer will wait for acknowledgments from ",(0,r.jsx)(n.strong,{children:"all in-sync replicas (ISRs)"})," before considering the message sent."]}),"\n",(0,r.jsxs)(n.li,{children:["Ensures ",(0,r.jsx)(n.strong,{children:"maximum durability"})," and ",(0,r.jsx)(n.strong,{children:"stronger data consistency"})," as all replicas need to confirm the message."]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"4",children:["\n",(0,r.jsx)(n.li,{children:"Kafka Producer Retries"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"retries"})," configuration determines the number of times the producer will ",(0,r.jsx)(n.strong,{children:"retry"})," sending a message if a send request fails (e.g., due to a temporary network issue or a broker being down)."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Retries"}),": If a message fails to send, the producer will automatically attempt to resend it up to the number specified by the ",(0,r.jsx)(n.code,{children:"retries"})," configuration."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transient Issues"}),": This is useful for ensuring that ",(0,r.jsx)(n.strong,{children:"transient issues"})," do not result in message loss, as the producer can retry until the message is successfully acknowledged."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Combining with ",(0,r.jsx)(n.code,{children:"acks=all"})]}),": When used with ",(0,r.jsx)(n.code,{children:"acks=all"}),", the producer can retry sending messages that have not been acknowledged by ",(0,r.jsx)(n.strong,{children:"all in-sync replicas (ISRs)"}),".","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This ensures that even if there are issues with one broker, the message can still be sent to the ",(0,r.jsx)(n.strong,{children:"other available brokers"}),", preserving durability and availability."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},47184:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/1-2f3e66c7737f06eab220156876cf23a3.png"},61003:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2-306bc98bb8b5ae4987c45dd1a37a17f4.png"},92754:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/10-c11f18327cde6703e7a4b119acec9795.png"}}]);
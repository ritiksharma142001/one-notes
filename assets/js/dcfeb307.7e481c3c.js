"use strict";(globalThis.webpackChunkes_note=globalThis.webpackChunkes_note||[]).push([[1721],{28453(e,n,s){s.d(n,{R:()=>t,x:()=>l});var i=s(96540);const r={},a=i.createContext(r);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}},43985(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"core-java/Collections/3","title":"3","description":"Map Hierarchy in Java","source":"@site/docs/core-java/Collections/3.md","sourceDirName":"core-java/Collections","slug":"/core-java/Collections/3","permalink":"/one-notes/core-java/Collections/3","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/core-java/Collections/3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"2","permalink":"/one-notes/core-java/Collections/2"},"next":{"title":"advance","permalink":"/one-notes/core-java/Collections/advance"}}');var r=s(74848),a=s(28453);const t={sidebar_position:3},l=void 0,d={},o=[{value:"Example Demonstrating Map Hierarchy:",id:"example-demonstrating-map-hierarchy",level:3},{value:"<strong>ClassCastException in Java</strong>",id:"classcastexception-in-java",level:3},{value:"<strong>Example of ClassCastException</strong>",id:"example-of-classcastexception",level:4},{value:"<strong>Understanding Map Implementations</strong>",id:"understanding-map-implementations",level:3},{value:"<strong>Homogeneous vs. Heterogeneous Keys and Values</strong>",id:"homogeneous-vs-heterogeneous-keys-and-values",level:3},{value:"<strong>Sorting and Order Maintenance</strong>",id:"sorting-and-order-maintenance",level:3},{value:"<strong>Example Code Demonstrating Differences</strong>",id:"example-code-demonstrating-differences",level:3},{value:"<strong>Key Takeaways</strong>",id:"key-takeaways",level:3},{value:"<strong>1. ArrayList and LinkedList Overview</strong>",id:"1-arraylist-and-linkedlist-overview",level:3},{value:"<strong>2. Storing Heterogeneous Data</strong>",id:"2-storing-heterogeneous-data",level:3},{value:"<strong>3. Sorting in ArrayList and LinkedList</strong>",id:"3-sorting-in-arraylist-and-linkedlist",level:3},{value:"<strong>4. Searching Mechanisms</strong>",id:"4-searching-mechanisms",level:3},{value:"<strong>5. Performance Differences</strong>",id:"5-performance-differences",level:3},{value:"<strong>6. Example Code</strong>",id:"6-example-code",level:3},{value:"<strong>ArrayList Example</strong>",id:"arraylist-example",level:4},{value:"<strong>LinkedList Example</strong>",id:"linkedlist-example",level:4},{value:"<strong>7. When to Use What?</strong>",id:"7-when-to-use-what",level:3},{value:"Introduction",id:"introduction",level:3},{value:"Key Points",id:"key-points",level:3},{value:"Iteration Methods",id:"iteration-methods",level:3},{value:"Java Code Example",id:"java-code-example",level:3},{value:"Explanation",id:"explanation",level:3},{value:"Summary",id:"summary",level:3},{value:"Introduction",id:"introduction-1",level:3},{value:"Key Features",id:"key-features",level:3},{value:"Common Methods",id:"common-methods",level:3},{value:"Example Code",id:"example-code",level:3},{value:"Differences: HashTable vs. HashMap",id:"differences-hashtable-vs-hashmap",level:3},{value:"When to Use HashTable?",id:"when-to-use-hashtable",level:3},{value:"Alternative: ConcurrentHashMap",id:"alternative-concurrenthashmap",level:3},{value:"Conclusion",id:"conclusion",level:3}];function c(e){const n={code:"code",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Map Hierarchy in Java"})}),"\n",(0,r.jsxs)(n.p,{children:["In Java, the ",(0,r.jsx)(n.code,{children:"Map"})," interface is part of the ",(0,r.jsx)(n.code,{children:"java.util"})," package and provides a way to store key-value pairs. Under the ",(0,r.jsx)(n.code,{children:"Map"})," hierarchy, there are three commonly used classes:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HashMap"})," - An unordered collection that allows ",(0,r.jsx)(n.code,{children:"null"})," keys and values."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TreeMap"})," - A sorted collection that does not allow ",(0,r.jsx)(n.code,{children:"null"})," keys but allows ",(0,r.jsx)(n.code,{children:"null"})," values. It sorts elements based on the natural ordering of keys or using a ",(0,r.jsx)(n.code,{children:"Comparator"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LinkedHashMap"})," - Maintains insertion order while allowing ",(0,r.jsx)(n.code,{children:"null"})," keys and values."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-demonstrating-map-hierarchy",children:"Example Demonstrating Map Hierarchy:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class MapHierarchyExample {\n    public static void main(String[] args) {\n        // HashMap Example\n        HashMap<Integer, String> hashMap = new HashMap<>();\n        hashMap.put(3, "Apple");\n        hashMap.put(1, "Banana");\n        hashMap.put(2, "Cherry");\n        System.out.println("HashMap (Unordered): " + hashMap);\n\n        // TreeMap Example\n        TreeMap<Integer, String> treeMap = new TreeMap<>(hashMap);\n        System.out.println("TreeMap (Sorted by Key): " + treeMap);\n\n        // LinkedHashMap Example\n        LinkedHashMap<Integer, String> linkedHashMap = new LinkedHashMap<>();\n        linkedHashMap.put(3, "Apple");\n        linkedHashMap.put(1, "Banana");\n        linkedHashMap.put(2, "Cherry");\n        System.out.println("LinkedHashMap (Insertion Order): " + linkedHashMap);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"classcastexception-in-java",children:(0,r.jsx)(n.strong,{children:"ClassCastException in Java"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"ClassCastException"})," occurs when trying to cast an object of one class into another incompatible class. This often happens in ",(0,r.jsx)(n.code,{children:"TreeMap"})," when attempting to store heterogeneous (different data types) keys that do not implement ",(0,r.jsx)(n.code,{children:"Comparable"})," or when manually casting between incompatible types."]}),"\n",(0,r.jsx)(n.h4,{id:"example-of-classcastexception",children:(0,r.jsx)(n.strong,{children:"Example of ClassCastException"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class ClassCastExceptionExample {\n    public static void main(String[] args) {\n        TreeMap<Object, String> treeMap = new TreeMap<>();\n        \n        treeMap.put("One", "Apple");\n        treeMap.put(2, "Banana"); // ClassCastException will occur here\n        \n        System.out.println(treeMap);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Poultry Map and Key-Value Characteristics in Map Implementations"})}),"\n",(0,r.jsx)(n.h3,{id:"understanding-map-implementations",children:(0,r.jsx)(n.strong,{children:"Understanding Map Implementations"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Map"})," interface in Java provides a data structure for storing key-value pairs. There are three primary implementations under ",(0,r.jsx)(n.code,{children:"Map"}),": ",(0,r.jsx)(n.code,{children:"HashMap"}),", ",(0,r.jsx)(n.code,{children:"LinkedHashMap"}),", and ",(0,r.jsx)(n.code,{children:"TreeMap"}),". Each of these differs in how they handle key uniqueness, order maintenance, and searching efficiency."]}),"\n",(0,r.jsx)(n.h3,{id:"homogeneous-vs-heterogeneous-keys-and-values",children:(0,r.jsx)(n.strong,{children:"Homogeneous vs. Heterogeneous Keys and Values"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Homogeneous Keys"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Keys of the same type (e.g., all ",(0,r.jsx)(n.code,{children:"String"})," keys or all ",(0,r.jsx)(n.code,{children:"Integer"})," keys)."]}),"\n",(0,r.jsxs)(n.li,{children:["Ensures consistent ordering in ",(0,r.jsx)(n.code,{children:"TreeMap"})," and efficient retrieval."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Homogeneous Values"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Values of the same type (e.g., all ",(0,r.jsx)(n.code,{children:"String"})," values or all ",(0,r.jsx)(n.code,{children:"Integer"})," values)."]}),"\n",(0,r.jsx)(n.li,{children:"Useful when processing collections of similar types."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Heterogeneous Keys"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HashMap"})," and ",(0,r.jsx)(n.code,{children:"LinkedHashMap"})," allow heterogeneous keys (different data types for keys), but ",(0,r.jsx)(n.code,{children:"TreeMap"})," does not (it requires ",(0,r.jsx)(n.code,{children:"Comparable"})," keys)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Heterogeneous Values"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Any ",(0,r.jsx)(n.code,{children:"Map"})," implementation allows heterogeneous values, as values do not affect sorting or uniqueness."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sorting-and-order-maintenance",children:(0,r.jsx)(n.strong,{children:"Sorting and Order Maintenance"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"HashMap"})})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Allows heterogeneous keys."}),"\n",(0,r.jsx)(n.li,{children:"Does not maintain the order of insertion."}),"\n",(0,r.jsx)(n.li,{children:"Provides fast search operations using hashing."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"LinkedHashMap"})})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Allows heterogeneous keys."}),"\n",(0,r.jsx)(n.li,{children:"Maintains the order of insertion."}),"\n",(0,r.jsx)(n.li,{children:"Searching is done based on keys while preserving order."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"TreeMap"})})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Does not allow heterogeneous keys (requires keys to be ",(0,r.jsx)(n.code,{children:"Comparable"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"Maintains keys in sorted order."}),"\n",(0,r.jsx)(n.li,{children:"Searching is efficient as it uses a tree structure."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-code-demonstrating-differences",children:(0,r.jsx)(n.strong,{children:"Example Code Demonstrating Differences"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.*;\n\npublic class MapExample {\n    public static void main(String[] args) {\n        // HashMap Example\n        Map<Object, String> hashMap = new HashMap<>();\n        hashMap.put(1, "Chicken");\n        hashMap.put("Egg", "Golden");\n        hashMap.put(3.14, "Hen");\n        System.out.println("HashMap: " + hashMap);\n        \n        // LinkedHashMap Example\n        Map<Object, String> linkedHashMap = new LinkedHashMap<>();\n        linkedHashMap.put(1, "Chicken");\n        linkedHashMap.put("Egg", "Golden");\n        linkedHashMap.put(3.14, "Hen");\n        System.out.println("LinkedHashMap: " + linkedHashMap);\n        \n        // TreeMap Example (Only Homogeneous Keys Allowed)\n        Map<Integer, String> treeMap = new TreeMap<>();\n        treeMap.put(3, "Hen");\n        treeMap.put(1, "Chicken");\n        treeMap.put(2, "Egg");\n        System.out.println("TreeMap (Sorted by Key): " + treeMap);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"key-takeaways",children:(0,r.jsx)(n.strong,{children:"Key Takeaways"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HashMap"}),": Allows heterogeneous keys, does not maintain order."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LinkedHashMap"}),": Allows heterogeneous keys, maintains insertion order."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TreeMap"}),": Requires homogeneous keys (Comparable), maintains sorted order."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This understanding helps in choosing the appropriate ",(0,r.jsx)(n.code,{children:"Map"})," based on sorting, key constraints, and performance requirements."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ArrayList vs LinkedList in Storing and Managing Data"})}),"\n",(0,r.jsx)(n.h3,{id:"1-arraylist-and-linkedlist-overview",children:(0,r.jsx)(n.strong,{children:"1. ArrayList and LinkedList Overview"})}),"\n",(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.code,{children:"ArrayList"})," and ",(0,r.jsx)(n.code,{children:"LinkedList"})," are part of Java's ",(0,r.jsx)(n.code,{children:"List"})," interface and are used for dynamic storage of data. However, they differ in how they store and manage data."]}),"\n",(0,r.jsx)(n.h3,{id:"2-storing-heterogeneous-data",children:(0,r.jsx)(n.strong,{children:"2. Storing Heterogeneous Data"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ArrayList"}),": Stores data in a continuous memory location.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It allows heterogeneous data but is generally used with homogeneous data."}),"\n",(0,r.jsx)(n.li,{children:"New elements are appended at the last index."}),"\n",(0,r.jsx)(n.li,{children:"If memory is full, it creates a new larger array and copies existing elements."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LinkedList"}),": Uses nodes to store data.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each node contains the data and references to the next and previous nodes."}),"\n",(0,r.jsx)(n.li,{children:"Insertion happens at both the front and rear."}),"\n",(0,r.jsx)(n.li,{children:"It supports heterogeneous data more efficiently."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-sorting-in-arraylist-and-linkedlist",children:(0,r.jsx)(n.strong,{children:"3. Sorting in ArrayList and LinkedList"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ArrayList"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sorting is efficient due to contiguous memory storage."}),"\n",(0,r.jsxs)(n.li,{children:["Uses ",(0,r.jsx)(n.code,{children:"Collections.sort()"})," for quick sorting."]}),"\n",(0,r.jsx)(n.li,{children:"Preferred when sorting is a frequent operation."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LinkedList"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sorting is slower due to non-contiguous memory locations."}),"\n",(0,r.jsx)(n.li,{children:"Requires traversal of nodes."}),"\n",(0,r.jsx)(n.li,{children:"Preferred when sorting is not frequent but insertions are."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-searching-mechanisms",children:(0,r.jsx)(n.strong,{children:"4. Searching Mechanisms"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ArrayList"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Uses ",(0,r.jsx)(n.strong,{children:"binary search"})," for sorted data."]}),"\n",(0,r.jsx)(n.li,{children:"Faster lookup due to direct index access (O(1) for retrieval)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LinkedList"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Uses ",(0,r.jsx)(n.strong,{children:"linear search"})," as elements are stored non-contiguously."]}),"\n",(0,r.jsx)(n.li,{children:"Searching is in order of insertion, making lookups slower (O(n) time complexity)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-performance-differences",children:(0,r.jsx)(n.strong,{children:"5. Performance Differences"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"ArrayList"}),(0,r.jsx)(n.th,{children:"LinkedList"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Memory Allocation"}),(0,r.jsx)(n.td,{children:"Continuous block"}),(0,r.jsx)(n.td,{children:"Dispersed nodes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Data Insertion"}),(0,r.jsx)(n.td,{children:"Slow at front, fast at end"}),(0,r.jsx)(n.td,{children:"Fast at front and rear"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Sorting"}),(0,r.jsx)(n.td,{children:"Faster, uses indexing"}),(0,r.jsx)(n.td,{children:"Slower, requires traversal"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Searching"}),(0,r.jsx)(n.td,{children:"Fast using index (O(1))"}),(0,r.jsx)(n.td,{children:"Slower, requires traversal (O(n))"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"6-example-code",children:(0,r.jsx)(n.strong,{children:"6. Example Code"})}),"\n",(0,r.jsx)(n.h4,{id:"arraylist-example",children:(0,r.jsx)(n.strong,{children:"ArrayList Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.*;\npublic class ArrayListExample {\n    public static void main(String[] args) {\n        ArrayList<Object> list = new ArrayList<>();\n        list.add("Apple");\n        list.add(10);\n        list.add(3.14);\n        System.out.println("ArrayList: " + list);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"linkedlist-example",children:(0,r.jsx)(n.strong,{children:"LinkedList Example"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.*;\npublic class LinkedListExample {\n    public static void main(String[] args) {\n        LinkedList<Object> list = new LinkedList<>();\n        list.addFirst("Parrot");\n        list.addLast("Banana");\n        list.add(1, 25);\n        System.out.println("LinkedList: " + list);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"7-when-to-use-what",children:(0,r.jsx)(n.strong,{children:"7. When to Use What?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"ArrayList"})," when fast retrieval and sorting are required."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.strong,{children:"LinkedList"})," when frequent insertions and deletions are needed."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Understanding these differences helps in selecting the right data structure for efficient program execution."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes on HashMap Iteration and Access Methods in Java"})}),"\n",(0,r.jsx)(n.h3,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"HashMap"})," in Java is a collection that stores key-value pairs. It allows efficient retrieval, insertion, and deletion operations. This document explains different ways to access and iterate over a ",(0,r.jsx)(n.code,{children:"HashMap"})," using keys, values, and entry sets."]}),"\n",(0,r.jsx)(n.h3,{id:"key-points",children:"Key Points"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"HashMap"})," does not maintain any order of insertion."]}),"\n",(0,r.jsx)(n.li,{children:"It allows unique keys but can have duplicate values."}),"\n",(0,r.jsxs)(n.li,{children:["Methods like ",(0,r.jsx)(n.code,{children:"keySet()"}),", ",(0,r.jsx)(n.code,{children:"values()"}),", and ",(0,r.jsx)(n.code,{children:"entrySet()"})," help in accessing different parts of a ",(0,r.jsx)(n.code,{children:"HashMap"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"iteration-methods",children:"Iteration Methods"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Accessing Values Using ",(0,r.jsx)(n.code,{children:"values()"})," Method:"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This method returns a ",(0,r.jsx)(n.code,{children:"Collection"})," of all values stored in the ",(0,r.jsx)(n.code,{children:"HashMap"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["We can use an ",(0,r.jsx)(n.code,{children:"Iterator"})," to loop through these values."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Accessing Keys Using ",(0,r.jsx)(n.code,{children:"keySet()"})," Method:"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This method returns a ",(0,r.jsx)(n.code,{children:"Set"})," containing all keys in the ",(0,r.jsx)(n.code,{children:"HashMap"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"We can iterate over this set to access individual keys."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Accessing Entries Using ",(0,r.jsx)(n.code,{children:"entrySet()"})," Method:"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["This method returns a ",(0,r.jsx)(n.code,{children:"Set"})," containing key-value pairs (",(0,r.jsx)(n.code,{children:"Map.Entry"})," objects)."]}),"\n",(0,r.jsx)(n.li,{children:"Iterating over this set allows us to access both keys and values simultaneously."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"java-code-example",children:"Java Code Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Creating a HashMap with Integer keys and String values\n        HashMap<Integer, String> map = new HashMap<>();\n        map.put(1, "one");\n        map.put(2, "two");\n        map.put(3, "three");\n        map.put(4, "four");\n        map.put(5, "five");\n        map.put(6, "six");\n\n        System.out.println("Initial map: " + map);\n\n        // Accessing values using values() method\n        Collection<String> values = map.values();\n        Iterator<String> iterator = values.iterator();\n        System.out.println("Iterating over values:");\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n        System.out.println("Final map: " + map);\n\n        // Accessing keys using keySet() method\n        Set<Integer> keys = map.keySet();\n        System.out.println("Iterating over keys:");\n        for (Integer key : keys) {\n            System.out.println(key);\n        }\n        System.out.println("Final map: " + map);\n\n        // Accessing entries using entrySet() method\n        Set<Map.Entry<Integer, String>> entries = map.entrySet();\n        System.out.println("Iterating over key-value pairs:");\n        for (Map.Entry<Integer, String> entry : entries) {\n            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());\n        }\n        System.out.println("Final map: " + map);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"explanation",children:"Explanation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"HashMap"})," is created and populated with key-value pairs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"values()"})," method is used to retrieve all values and iterate over them."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"keySet()"})," method is used to retrieve all keys and iterate over them."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"entrySet()"})," method is used to retrieve key-value pairs and iterate over them."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"HashMap"})," remains unchanged after iteration since no modifications are made."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"values()"})," for iterating over values."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"keySet()"})," for iterating over keys."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"entrySet()"})," for iterating over key-value pairs."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"HashMap"})," maintains high efficiency but does not guarantee insertion order."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This example illustrates fundamental ",(0,r.jsx)(n.code,{children:"HashMap"})," operations essential for working with key-value data structures in Java."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"HashTable in Java - Interview Guide"})}),"\n",(0,r.jsx)(n.h3,{id:"introduction-1",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"HashTable"})," in Java is a data structure that stores key-value pairs and provides fast retrieval. It is part of the ",(0,r.jsx)(n.code,{children:"java.util"})," package and implements the ",(0,r.jsx)(n.code,{children:"Map"})," interface."]}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe:"})," It is synchronized, making it suitable for multi-threaded environments."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No Null Keys or Values:"})," Unlike ",(0,r.jsx)(n.code,{children:"HashMap"}),", ",(0,r.jsx)(n.code,{children:"HashTable"})," does not allow ",(0,r.jsx)(n.code,{children:"null"})," keys or values."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Uses Hashing:"})," Keys are hashed to determine their storage location, ensuring fast lookups."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance:"})," Slightly slower than ",(0,r.jsx)(n.code,{children:"HashMap"})," due to synchronization."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-methods",children:"Common Methods"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"put(K key, V value)"}),": Adds a key-value pair."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"get(Object key)"}),": Retrieves a value for a given key."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"remove(Object key)"}),": Deletes an entry by key."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"containsKey(Object key)"}),": Checks if a key exists."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"containsValue(Object value)"}),": Checks if a value exists."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"size()"}),": Returns the number of key-value pairs."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-code",children:"Example Code"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.Hashtable;\n\npublic class HashTableExample {\n    public static void main(String[] args) {\n        Hashtable<Integer, String> table = new Hashtable<>();\n        \n        table.put(1, "Apple");\n        table.put(2, "Banana");\n        table.put(3, "Cherry");\n        \n        System.out.println("Value for key 2: " + table.get(2));\n        System.out.println("Contains key 3? " + table.containsKey(3));\n        \n        table.remove(1);\n        System.out.println("Table after removal: " + table);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"differences-hashtable-vs-hashmap",children:"Differences: HashTable vs. HashMap"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"HashTable"}),(0,r.jsx)(n.th,{children:"HashMap"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Synchronization"}),(0,r.jsx)(n.td,{children:"Yes (Thread-safe)"}),(0,r.jsx)(n.td,{children:"No (Not synchronized)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["Allows ",(0,r.jsx)(n.code,{children:"null"})," keys/values"]}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Performance"}),(0,r.jsx)(n.td,{children:"Slower due to synchronization"}),(0,r.jsx)(n.td,{children:"Faster"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Best Use Case"}),(0,r.jsx)(n.td,{children:"Multi-threaded applications"}),(0,r.jsx)(n.td,{children:"Single-threaded applications"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-hashtable",children:"When to Use HashTable?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["In ",(0,r.jsx)(n.strong,{children:"multi-threaded"})," applications where data consistency is required."]}),"\n",(0,r.jsxs)(n.li,{children:["When you do ",(0,r.jsx)(n.strong,{children:"not"})," need to store ",(0,r.jsx)(n.code,{children:"null"})," values."]}),"\n",(0,r.jsx)(n.li,{children:"When synchronization overhead is acceptable."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"alternative-concurrenthashmap",children:"Alternative: ConcurrentHashMap"}),"\n",(0,r.jsxs)(n.p,{children:["If you need a thread-safe alternative with better performance, use ",(0,r.jsx)(n.code,{children:"ConcurrentHashMap"}),", which allows concurrent access with minimal locking."]}),"\n",(0,r.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"HashTable"})," is a powerful but slightly outdated data structure in Java. For thread-safety with better performance, ",(0,r.jsx)(n.code,{children:"ConcurrentHashMap"})," is recommended. Understanding ",(0,r.jsx)(n.code,{children:"HashTable"})," is crucial for Java interviews as it helps in grasping concurrent collections."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);
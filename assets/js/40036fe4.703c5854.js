"use strict";(globalThis.webpackChunkes_note=globalThis.webpackChunkes_note||[]).push([[7439],{28453(n,e,r){r.d(e,{R:()=>s,x:()=>a});var t=r(96540);const c={},i=t.createContext(c);function s(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:s(n.components),t.createElement(i.Provider,{value:e},n.children)}},81834(n,e,r){r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core-java/oops/Abstraction_1","title":"Abstraction-2","description":"---","source":"@site/docs/core-java/oops/6. Abstraction_1.md","sourceDirName":"core-java/oops","slug":"/core-java/oops/Abstraction_1","permalink":"/one-notes/core-java/oops/Abstraction_1","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/core-java/oops/6. Abstraction_1.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Abstraction","permalink":"/one-notes/core-java/oops/Abstraction"},"next":{"title":"Exception Handling","permalink":"/one-notes/category/exception-handling"}}');var c=r(74848),i=r(28453);const s={sidebar_position:5},a="Abstraction-2",o={},l=[{value:"1. Object Creation and Constructor Chaining",id:"1-object-creation-and-constructor-chaining",level:2},{value:"2. How Constructor Chaining Works",id:"2-how-constructor-chaining-works",level:2},{value:"3. You Can&#39;t Instantiate <code>Teacher</code> Directly, But It&#39;s Still Involved",id:"3-you-cant-instantiate-teacher-directly-but-its-still-involved",level:2},{value:"Here&#39;s the Flow of Execution",id:"heres-the-flow-of-execution",level:2},{value:"Why Is the Static Block of <code>Teacher</code> Called?",id:"why-is-the-static-block-of-teacher-called",level:2},{value:"Class Loading Order",id:"class-loading-order",level:3},{value:"Execution Order When You Run the Code",id:"execution-order-when-you-run-the-code",level:2},{value:"Abstraction using Interface",id:"abstraction-using-interface",level:2}];function d(n){const e={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(e.header,{children:(0,c.jsx)(e.h1,{id:"abstraction-2",children:"Abstraction-2"})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'abstract class Teacher{\r\n    abstract void teach();\r\n    abstract void project();\r\n}\r\n\r\nclass JavaTeacher extends Teacher{\r\n    void teach(){\r\n        System.out.println("Teaching Java");\r\n    }\r\n    void project(){\r\n        System.out.println("Java Project");\r\n    }\r\n}\r\nclass PythonTeacher extends Teacher{\r\n    void teach(){\r\n        System.out.println("Teaching Python");\r\n    }\r\n    void project(){\r\n        System.out.println("Python Project");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void teacherBehaviour(Teacher t){\r\n        t.teach();\r\n        t.project();\r\n    }\r\n    public static void main(String[] args) {\r\n        JavaTeacher j = new JavaTeacher();\r\n        PythonTeacher p = new PythonTeacher();\r\n        teacherBehaviour(j);\r\n        teacherBehaviour(p);\r\n    }\r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"abstract class Teacher{\r\n    abstract void teach();\r\n    abstract void project();\r\n}\n"})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'abstract class Teacher{\r\n    abstract void teach();\r\n    void project(){\r\n        System.out.println("Project");\r\n    }\r\n}\n'})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'abstract class Teacher{\r\n    void teach(){\r\n        System.out.println("Teach");\r\n    }\r\n    void project(){\r\n        System.out.println("Project");\r\n    }\r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'\r\nabstract class Teacher{\r\n    abstract void teach();\r\n    abstract void project();\r\n}\r\nabstract class JavaTeacher extends Teacher{\r\n    void teach(){\r\n        System.out.println("Teaching Java");\r\n    }\r\n}\r\nclass PythonTeacher extends Teacher{\r\n    void teach(){\r\n        System.out.println("Teaching Python");\r\n    }\r\n    void project(){\r\n        System.out.println("Working on Python project");\r\n    }\r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'abstract class Teacher{\r\n    abstract void teach();\r\n    abstract void project();\r\n    void attendance(){\r\n        System.out.println("Attendance is taken");\r\n    }\r\n}\r\nabstract class JavaTeacher extends Teacher{\r\n    void teach(){\r\n        System.out.println("Teaching Java");\r\n    }\r\n}\r\nclass PythonTeacher extends Teacher{\r\n    void teach(){\r\n        System.out.println("Teaching Python");\r\n    }\r\n    void project(){\r\n        System.out.println("Working on Python project");\r\n    }\r\n}\r\n\r\n\r\npublic class Main {\r\n    \r\n    public static void main(String[] args) {\r\n       PythonTeacher pt = new PythonTeacher();\r\n       pt.teach();\r\n       pt.attendance();\r\n    }\r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'abstract class Teacher{\r\n    abstract void teach();\r\n    abstract void project();\r\n    final void study(){\r\n        System.out.println("Study");\r\n    }\r\n    abstract final void exam();\r\n    abstract static void test();\r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'\r\nabstract class Teacher{\r\n    static int x;\r\n    static{\r\n        x = 10;\r\n        System.out.println("Static block of Teacher");\r\n    }\r\n    static void display(){\r\n        System.out.println("Static method of Teacher");\r\n    }\r\n    int y;\r\n    {\r\n        y = 20;\r\n        System.out.println("Instance block of Teacher");\r\n    }\r\n    void show(){\r\n        System.out.println("Instance method of Teacher");\r\n    }\r\n    Teacher(){\r\n        System.out.println("Constructor of Teacher");\r\n    }\r\n    abstract void teach();\r\n}\r\nclass JavaTeacher extends Teacher{\r\n    static int a;\r\n    static{\r\n        a = 30;\r\n        System.out.println("Static block of JavaTeacher");\r\n    }\r\n    static void display(){\r\n        System.out.println("Static method of JavaTeacher");\r\n    }\r\n    int b;\r\n    {\r\n        b = 40;\r\n        System.out.println("Instance block of JavaTeacher");\r\n    }\r\n    void show(){\r\n        System.out.println("Instance method of JavaTeacher");\r\n    }\r\n    JavaTeacher(){\r\n        System.out.println("Constructor of JavaTeacher");\r\n    }\r\n    void teach(){\r\n        System.out.println("Teaching Java");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n       JavaTeacher obj = new JavaTeacher();\r\n       obj.teach();\r\n    }\r\n}\r\n\r\n\r\n// Static block of Teacher\r\n// Static block of JavaTeacher\r\n// Instance block of Teacher\r\n// Constructor of Teacher\r\n// Instance block of JavaTeacher\r\n// Constructor of JavaTeacher\r\n// Teaching Java\r\n\n'})}),"\n",(0,c.jsx)(e.h1,{id:"constructor-chaining-in-java-with-abstract-classes",children:"Constructor Chaining in Java with Abstract Classes"}),"\n",(0,c.jsxs)(e.p,{children:["The reason the ",(0,c.jsxs)(e.strong,{children:["constructor of ",(0,c.jsx)(e.code,{children:"Teacher"})]})," is called, even though you cannot create an object of the ",(0,c.jsx)(e.code,{children:"Teacher"})," class directly, is because ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," is a subclass of ",(0,c.jsx)(e.code,{children:"Teacher"}),". When you create an object of ",(0,c.jsx)(e.code,{children:"JavaTeacher"}),", it still inherits the constructor of ",(0,c.jsx)(e.code,{children:"Teacher"}),", and the ",(0,c.jsxs)(e.strong,{children:["constructor of the superclass (",(0,c.jsx)(e.code,{children:"Teacher"}),")"]})," is called as part of the object creation process."]}),"\n",(0,c.jsx)(e.h2,{id:"1-object-creation-and-constructor-chaining",children:"1. Object Creation and Constructor Chaining"}),"\n",(0,c.jsxs)(e.p,{children:["When you create an object of a subclass (in this case, ",(0,c.jsx)(e.code,{children:"JavaTeacher"}),"), the constructor of the ",(0,c.jsx)(e.strong,{children:"parent class"})," (",(0,c.jsx)(e.code,{children:"Teacher"}),") is always called ",(0,c.jsx)(e.strong,{children:"first"})," before the constructor of the subclass (",(0,c.jsx)(e.code,{children:"JavaTeacher"}),"). This is called ",(0,c.jsx)(e.strong,{children:"constructor chaining"}),"."]}),"\n",(0,c.jsxs)(e.p,{children:["Even though you can't instantiate the ",(0,c.jsx)(e.code,{children:"Teacher"})," class directly, the subclass (",(0,c.jsx)(e.code,{children:"JavaTeacher"}),") still needs to initialize the parent class (",(0,c.jsx)(e.code,{children:"Teacher"}),"), and this is done by calling the constructor of the parent class."]}),"\n",(0,c.jsx)(e.h2,{id:"2-how-constructor-chaining-works",children:"2. How Constructor Chaining Works"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["When the ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," constructor is invoked, the ",(0,c.jsx)(e.strong,{children:"default constructor"})," of ",(0,c.jsx)(e.code,{children:"Teacher"})," (the parent class) is automatically called first, unless you explicitly call a specific constructor of ",(0,c.jsx)(e.code,{children:"Teacher"})," using ",(0,c.jsx)(e.code,{children:"super()"}),"."]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["In your code, you did ",(0,c.jsxs)(e.strong,{children:["not explicitly call ",(0,c.jsx)(e.code,{children:"super()"})]}),", so the default constructor of ",(0,c.jsx)(e.code,{children:"Teacher"})," (which prints ",(0,c.jsx)(e.code,{children:'"Constructor of Teacher"'}),") is called automatically ",(0,c.jsx)(e.strong,{children:"before"})," the constructor of ",(0,c.jsx)(e.code,{children:"JavaTeacher"}),"."]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"3-you-cant-instantiate-teacher-directly-but-its-still-involved",children:["3. You Can't Instantiate ",(0,c.jsx)(e.code,{children:"Teacher"})," Directly, But It's Still Involved"]}),"\n",(0,c.jsxs)(e.p,{children:["Even though you can't instantiate ",(0,c.jsx)(e.code,{children:"Teacher"})," directly because it's abstract, Java ",(0,c.jsx)(e.strong,{children:"still calls its constructor"})," as part of the object creation process of the ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," class."]}),"\n",(0,c.jsxs)(e.p,{children:["The constructor of ",(0,c.jsx)(e.code,{children:"Teacher"})," is executed to ensure the proper initialization of any inherited fields or methods from ",(0,c.jsx)(e.code,{children:"Teacher"})," that the ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," class might use."]}),"\n",(0,c.jsx)(e.h2,{id:"heres-the-flow-of-execution",children:"Here's the Flow of Execution"}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Static block of ",(0,c.jsx)(e.code,{children:"Teacher"})]})," is executed (since ",(0,c.jsx)(e.code,{children:"Teacher"})," is loaded when ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," is instantiated)."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Static block of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})]})," is executed (since ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," is now being loaded)."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Instance block of ",(0,c.jsx)(e.code,{children:"Teacher"})]})," is executed (instance initialization for the superclass)."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Constructor of ",(0,c.jsx)(e.code,{children:"Teacher"})]})," is executed (initializing the superclass part of the object)."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Instance block of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})]})," is executed (instance initialization for the subclass)."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Constructor of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})]})," is executed (initializing the subclass part of the object)."]}),"\n",(0,c.jsxs)(e.li,{children:["Finally, the ",(0,c.jsx)(e.code,{children:"teach()"})," method of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," is called."]}),"\n"]}),"\n",(0,c.jsx)(e.h1,{id:"understanding-static-block-execution-order-in-java",children:"Understanding Static Block Execution Order in Java"}),"\n",(0,c.jsxs)(e.p,{children:["In Java, ",(0,c.jsx)(e.strong,{children:"static blocks"})," are executed when a class is ",(0,c.jsx)(e.strong,{children:"loaded into memory for the first time"}),". When you create an object of a class (e.g., ",(0,c.jsx)(e.code,{children:"JavaTeacher obj = new JavaTeacher();"}),"), ",(0,c.jsxs)(e.strong,{children:["both the parent class (",(0,c.jsx)(e.code,{children:"Teacher"}),") and the child class (",(0,c.jsx)(e.code,{children:"JavaTeacher"}),")"]})," are loaded into memory."]}),"\n",(0,c.jsxs)(e.h2,{id:"why-is-the-static-block-of-teacher-called",children:["Why Is the Static Block of ",(0,c.jsx)(e.code,{children:"Teacher"})," Called?"]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Static blocks"})," execute when the ",(0,c.jsx)(e.strong,{children:"class is loaded"}),", regardless of whether an object is created or not."]}),"\n",(0,c.jsxs)(e.li,{children:["When you create an object of ",(0,c.jsx)(e.code,{children:"JavaTeacher"}),", both ",(0,c.jsx)(e.code,{children:"Teacher"})," (its superclass) and ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," (the subclass) are loaded into memory."]}),"\n"]}),"\n",(0,c.jsx)(e.h3,{id:"class-loading-order",children:"Class Loading Order"}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["When the ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," class is loaded for the first time, the ",(0,c.jsx)(e.code,{children:"Teacher"})," class (its superclass) is ",(0,c.jsx)(e.strong,{children:"loaded first"})," because ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," extends ",(0,c.jsx)(e.code,{children:"Teacher"}),"."]}),"\n",(0,c.jsxs)(e.li,{children:["As part of loading the ",(0,c.jsx)(e.code,{children:"Teacher"})," class, the ",(0,c.jsxs)(e.strong,{children:["static blocks in ",(0,c.jsx)(e.code,{children:"Teacher"})]})," are executed."]}),"\n",(0,c.jsxs)(e.li,{children:["After the ",(0,c.jsx)(e.code,{children:"Teacher"})," static block completes, the ",(0,c.jsxs)(e.strong,{children:["static block of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})]})," is executed."]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"execution-order-when-you-run-the-code",children:"Execution Order When You Run the Code"}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Static block of ",(0,c.jsx)(e.code,{children:"Teacher"})]})," is executed first",(0,c.jsx)(e.br,{}),"\n",(0,c.jsxs)(e.em,{children:["(because ",(0,c.jsx)(e.code,{children:"Teacher"})," is the superclass and is loaded first)"]}),"."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Static block of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})]})," is executed next",(0,c.jsx)(e.br,{}),"\n",(0,c.jsxs)(e.em,{children:["(because ",(0,c.jsx)(e.code,{children:"JavaTeacher"})," is now being loaded)"]}),"."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Instance block of ",(0,c.jsx)(e.code,{children:"Teacher"})]})," is executed",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)(e.em,{children:"(instance initialization of the superclass)"}),"."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Constructor of ",(0,c.jsx)(e.code,{children:"Teacher"})]})," is executed",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)(e.em,{children:"(initializing the superclass part of the object)"}),"."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Instance block of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})]})," is executed",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)(e.em,{children:"(instance initialization of the subclass)"}),"."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsxs)(e.strong,{children:["Constructor of ",(0,c.jsx)(e.code,{children:"JavaTeacher"})]})," is executed",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)(e.em,{children:"(initializing the subclass part of the object)"}),"."]}),"\n"]}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.h2,{id:"abstraction-using-interface",children:"Abstraction using Interface"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'interface StudentActivities {\r\n    void study(); // abstract void study();\r\n}\r\nclass PhysicsStudent implements StudentActivities {\r\n    @Override\r\n    public void study() {\r\n        System.out.println("Studying Physics");\r\n    }\r\n}\r\nclass MathStudent implements StudentActivities {\r\n    @Override\r\n    public void study() {\r\n        System.out.println("Studying Math");\r\n    }\r\n}\r\npublic class Main {\r\n    static void study(StudentActivities studentActivities) {\r\n        studentActivities.study();\r\n    }\r\n    public static void main(String[] args) {\r\n       PhysicsStudent physicsStudent = new PhysicsStudent();\r\n       MathStudent mathStudent = new MathStudent();\r\n       study(physicsStudent);\r\n       study(mathStudent);\r\n    }\r\n}\r\n\r\n// Studying Physics\r\n// Studying Math\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'interface Calculator {\r\n    void add(); // public abstract void add();\r\n    void sub();\r\n}\r\nclass MyCalculator implements Calculator {\r\n    public void add() {\r\n        System.out.println("Addition");\r\n    }\r\n    public void sub() {\r\n        System.out.println("Subtraction");\r\n    }\r\n}\r\npublic class Main {\r\n    \r\n    public static void main(String[] args) {\r\n    //    Calculator c = new Calculator(); // cannot instantiate the type Calculator\r\n        Calculator c = new MyCalculator();\r\n        c.add();\r\n        c.sub();\r\n\r\n        Calculator c2;\r\n        MyCalculator mc = new MyCalculator();\r\n        c2 = mc;\r\n        c2.add();\r\n        c2.sub();\r\n    }\r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"interface Calculator {\r\n    int a = 20;\r\n    public static final int b = 10;\r\n    // int c; // error because all the fields in interface are final and static\r\n}\r\nclass MyCal implements Calculator{\r\n    void change(){\r\n        // a = 30; // error because all the fields in interface are final and static\r\n        // b = 20; // error because all the fields in interface are final and static\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    \r\n    public static void main(String[] args) {\r\n        System.out.println(MyCal.a); // 20\r\n        System.out.println(MyCal.b); // 10\r\n    }\r\n}\r\n\n"})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'interface Cal{\r\n    void add();\r\n    void sub();\r\n}\r\nabstract class Cal1 implements Cal{\r\n    public void add(){\r\n        System.out.println("Addition");\r\n    }\r\n    // not providing implementation for sub\r\n    // so this class is abstract\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n    } \r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'interface cal1{\r\n    void add();\r\n}\r\ninterface cal2{\r\n    void sub();\r\n}   \r\ninterface cal3{\r\n    void mul();\r\n}\r\nclass Mycal implements cal1,cal2,cal3{\r\n    public void add(){\r\n        System.out.println("Addition");\r\n    }\r\n    public void sub(){\r\n        System.out.println("Subtraction");\r\n    }\r\n    public void mul(){\r\n        System.out.println("Multiplication");\r\n    }\r\n}\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Mycal obj = new Mycal();\r\n        obj.add();\r\n        obj.sub();\r\n        obj.mul();\r\n    } \r\n}\r\n\r\n// Addition\r\n// Subtraction\r\n// Multiplication\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'interface cal1{\r\n    void add();\r\n}\r\ninterface cal2 extends cal1{\r\n    void sub();\r\n}   \r\nclass MyCal implements cal2{\r\n    public void add(){\r\n        System.out.println("Addition");\r\n    }\r\n    public void sub(){\r\n        System.out.println("Subtraction");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        \r\n    } \r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'interface cal1{\r\n    void add();\r\n}\r\ninterface cal2 {\r\n    void sub();\r\n}   \r\nclass Mycal1 {\r\n    public void add() {\r\n        System.out.println("Addition");\r\n    }\r\n}\r\n\r\n\r\nclass Mycal3 extends Mycal1 implements cal1, cal2 {\r\n    public void sub() {\r\n        System.out.println("Subtraction");\r\n    }\r\n}\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        \r\n    } \r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"interface cal1{\r\n    // Marker Interface\r\n    // It is an interface with no methods or fields.\r\n}\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        \r\n    } \r\n}\n"})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:'interface cal1{\r\n    public abstract void disp1();\r\n    public default void disp2(){\r\n        System.out.println("Default Method");\r\n    }\r\n    public static void disp3(){\r\n        System.out.println("Static Method");\r\n    }\r\n    private void disp4(){\r\n        System.out.println("Private Method"); // not accessible outside interface\r\n    }\r\n}\r\nclass cal2 implements cal1{\r\n    public void disp1(){\r\n        System.out.println("Abstract Method");\r\n    }\r\n    public void disp2(){\r\n        System.out.println("Default Method Overriden");\r\n    }\r\n    public void disp4(){\r\n        System.out.println("Private Method Overriden");\r\n    }\r\n    public static void disp3(){\r\n        System.out.println("Static Method Overriden"); //this does not override static method\r\n        // just the another method with same name\r\n    }\r\n}\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        // cal1 obj = new cal2();\r\n        // obj.disp1();\r\n        // obj.disp2();\r\n        // cal1.disp3();\r\n        // // print static method overridden\r\n        // cal2.disp3();\r\n        // // print private method overridden\r\n        // // obj.disp4();\r\n\r\n        cal1 obj = new cal2();\r\n        obj.disp1();  // Calls the abstract method (overridden in cal2)\r\n\r\n        obj.disp2();  // Calls the default method (overridden in cal2)\r\n\r\n        // Calling the static method of cal1 (from the interface)\r\n        cal1.disp3();  // Output: Static Method\r\n\r\n        // Calling the static method of cal2 (overrides the static method of cal1)\r\n        cal2.disp3();  // Output: Static Method Overridden\r\n\r\n        // Cannot access private methods from the interface\r\n        // obj.disp4();  // This will cause a compile-time error because disp4 is private\r\n\r\n\r\n    } \r\n}\n'})}),"\n",(0,c.jsx)(e.hr,{})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(d,{...n})}):d(n)}}}]);
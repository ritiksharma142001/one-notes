"use strict";(self.webpackChunkes_note=self.webpackChunkes_note||[]).push([[1037],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}},80881:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"core-java/oops/Abstraction","title":"Abstraction","description":"Abstraction in Java","source":"@site/docs/core-java/oops/5. Abstraction.md","sourceDirName":"core-java/oops","slug":"/core-java/oops/Abstraction","permalink":"/one-notes/core-java/oops/Abstraction","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/core-java/oops/5. Abstraction.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Polymorphism","permalink":"/one-notes/core-java/oops/Polymorphism"},"next":{"title":"Abstraction-2","permalink":"/one-notes/core-java/oops/Abstraction_1"}}');var a=s(74848),i=s(28453);const r={sidebar_position:5},l="Abstraction",c={},o=[{value:"<strong>Abstraction in Java</strong>",id:"abstraction-in-java",level:3},{value:"<strong>1. What is Abstraction?</strong>",id:"1-what-is-abstraction",level:4},{value:"<strong>2. Key Points About Abstraction</strong>",id:"2-key-points-about-abstraction",level:4},{value:"<strong>3. Example of Abstraction in Java</strong>",id:"3-example-of-abstraction-in-java",level:4},{value:"<strong>4. Explanation of the Code</strong>",id:"4-explanation-of-the-code",level:4},{value:"<strong>5. Key Takeaways</strong>",id:"5-key-takeaways",level:4},{value:"<strong>Pure and Impure Abstract Classes in Java</strong>",id:"pure-and-impure-abstract-classes-in-java",level:3},{value:"<strong>1. What is an Abstract Class?</strong>",id:"1-what-is-an-abstract-class",level:4},{value:"<strong>2. Types of Abstract Classes</strong>",id:"2-types-of-abstract-classes",level:4},{value:"<strong>(A) Pure Abstract Class</strong>",id:"a-pure-abstract-class",level:5},{value:"<strong>(B) Impure Abstract Class (Type 1)</strong>",id:"b-impure-abstract-class-type-1",level:5},{value:"<strong>(C) Impure Abstract Class (Type 2)</strong>",id:"c-impure-abstract-class-type-2",level:5},{value:"<strong>3. Why Can&#39;t Abstract Classes Be Instantiated?</strong>",id:"3-why-cant-abstract-classes-be-instantiated",level:4},{value:"<strong>4. Example Demonstrating Instantiation Restriction</strong>",id:"4-example-demonstrating-instantiation-restriction",level:4},{value:"<strong>5. Key Takeaways</strong>",id:"5-key-takeaways-1",level:4},{value:"<strong>Partial Abstraction in Java</strong>",id:"partial-abstraction-in-java",level:3},{value:"<strong>1. What is Partial Abstraction?</strong>",id:"1-what-is-partial-abstraction",level:4},{value:"<strong>2. Example of Partial Abstraction</strong>",id:"2-example-of-partial-abstraction",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways",level:4},{value:"<strong>Restrictions on Abstract Methods in Java</strong>",id:"restrictions-on-abstract-methods-in-java",level:3},{value:"<strong>1. Why Can&#39;t Abstract Methods Be <code>final</code> or <code>static</code>?</strong>",id:"1-why-cant-abstract-methods-be-final-or-static",level:4},{value:"<strong>(A) Abstract Methods Cannot Be <code>final</code></strong>",id:"a-abstract-methods-cannot-be-final",level:5},{value:"<strong>(B) Abstract Methods Cannot Be <code>static</code></strong>",id:"b-abstract-methods-cannot-be-static",level:5},{value:"<strong>2. Example Demonstrating Errors</strong>",id:"2-example-demonstrating-errors",level:4},{value:"<strong>3. Explanation of Errors</strong>",id:"3-explanation-of-errors",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-1",level:4},{value:"<strong>Understanding Static and Non-Static Members in an Abstract Class</strong>",id:"understanding-static-and-non-static-members-in-an-abstract-class",level:3},{value:"<strong>1. Components of an Abstract Class</strong>",id:"1-components-of-an-abstract-class",level:4},{value:"<strong>2. Example of an Abstract Class with Static and Non-Static Members</strong>",id:"2-example-of-an-abstract-class-with-static-and-non-static-members",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code-1",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-2",level:4},{value:"<strong>Abstraction Using Interfaces in Java</strong>",id:"abstraction-using-interfaces-in-java",level:3},{value:"<strong>1. What is an Interface?</strong>",id:"1-what-is-an-interface",level:4},{value:"<strong>2. Example of Abstraction Using an Interface</strong>",id:"2-example-of-abstraction-using-an-interface",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code-2",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-3",level:4},{value:"<strong>Why Were Interfaces Introduced in Java?</strong>",id:"why-were-interfaces-introduced-in-java",level:3},{value:"<strong>1. Reasons for Introducing Interfaces</strong>",id:"1-reasons-for-introducing-interfaces",level:4},{value:"<strong>2. Example of Interface Usage in Java</strong>",id:"2-example-of-interface-usage-in-java",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code-3",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-4",level:4},{value:"<strong>Interface Methods and Variables in Java</strong>",id:"interface-methods-and-variables-in-java",level:3},{value:"<strong>1. Key Properties of Interfaces</strong>",id:"1-key-properties-of-interfaces",level:4},{value:"<strong>2. Example Program: Implementing an Interface</strong>",id:"2-example-program-implementing-an-interface",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code-4",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-5",level:4},{value:"<strong>Partial Implementation of an Interface in Java</strong>",id:"partial-implementation-of-an-interface-in-java",level:3},{value:"<strong>1. Key Concept</strong>",id:"1-key-concept",level:4},{value:"<strong>2. Example Program: Partial Implementation of an Interface</strong>",id:"2-example-program-partial-implementation-of-an-interface",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code-5",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-6",level:4},{value:"<strong>Achieving Multiple Inheritance Using Interfaces in Java</strong>",id:"achieving-multiple-inheritance-using-interfaces-in-java",level:3},{value:"<strong>1. Key Concept</strong>",id:"1-key-concept-1",level:4},{value:"<strong>2. Example Program: Achieving Multiple Inheritance with Interfaces</strong>",id:"2-example-program-achieving-multiple-inheritance-with-interfaces",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code-6",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-7",level:4},{value:"<strong>Interface Inheritance in Java</strong>",id:"interface-inheritance-in-java",level:3},{value:"<strong>1. Key Concept</strong>",id:"1-key-concept-2",level:4},{value:"<strong>2. Example Program: Interface Extending Another Interface</strong>",id:"2-example-program-interface-extending-another-interface",level:4},{value:"<strong>3. Explanation of the Code</strong>",id:"3-explanation-of-the-code-7",level:4},{value:"<strong>4. Key Takeaways</strong>",id:"4-key-takeaways-8",level:4},{value:"<strong>Interface Inheritance in Java</strong>",id:"interface-inheritance-in-java-1",level:3},{value:"<strong>1. Key Concept</strong>",id:"1-key-concept-3",level:4},{value:"<strong>2. Example Program: Class Extending Another Class and Implementing an Interface</strong>",id:"2-example-program-class-extending-another-class-and-implementing-an-interface",level:4},{value:"<strong>3. Key Takeaways</strong>",id:"3-key-takeaways",level:4},{value:"<strong>Marker (Tag) Interface in Java</strong>",id:"marker-tag-interface-in-java",level:3},{value:"<strong>1. Key Concept</strong>",id:"1-key-concept-4",level:4},{value:"<strong>2. Example of a Marker Interface</strong>",id:"2-example-of-a-marker-interface",level:4},{value:"<strong>3. Key Takeaways</strong>",id:"3-key-takeaways-1",level:4},{value:"<strong>2. Example Program: Interface with Various Methods</strong>",id:"2-example-program-interface-with-various-methods",level:4},{value:"<strong>3. Key Takeaways</strong>",id:"3-key-takeaways-2",level:4}];function d(e){const n={code:"code",h1:"h1",h3:"h3",h4:"h4",h5:"h5",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"abstraction",children:"Abstraction"})}),"\n",(0,a.jsx)(n.h3,{id:"abstraction-in-java",children:(0,a.jsx)(n.strong,{children:"Abstraction in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-what-is-abstraction",children:(0,a.jsx)(n.strong,{children:"1. What is Abstraction?"})}),"\n",(0,a.jsxs)(n.p,{children:["Abstraction is the process of hiding irrelevant details and exposing only the essential features of an object. It can be achieved using ",(0,a.jsx)(n.strong,{children:"abstract classes"})," or ",(0,a.jsx)(n.strong,{children:"interfaces"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"2-key-points-about-abstraction",children:(0,a.jsx)(n.strong,{children:"2. Key Points About Abstraction"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"abstract"})," keyword is used to declare an ",(0,a.jsx)(n.strong,{children:"abstract class"})," and ",(0,a.jsx)(n.strong,{children:"abstract methods"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["An ",(0,a.jsx)(n.strong,{children:"abstract method"})," is a method that does not have a body; it must be implemented by subclasses."]}),"\n",(0,a.jsxs)(n.li,{children:["If a class contains at least one abstract method, it must be declared as an ",(0,a.jsx)(n.strong,{children:"abstract class"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://github.com/user-attachments/assets/3448c321-9fff-4533-8330-1a95907fa325",alt:"image"})}),"\n",(0,a.jsx)(n.h4,{id:"3-example-of-abstraction-in-java",children:(0,a.jsx)(n.strong,{children:"3. Example of Abstraction in Java"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Abstract class Teacher\nabstract class Teacher {\n    // Abstract methods (no body)\n    abstract void teach();\n    abstract void project();\n}\n\n// JavaTeacher class extending Teacher\nclass JavaTeacher extends Teacher {\n    @Override\n    void teach() {\n        System.out.println("Teaching Java programming");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Guiding Java project");\n    }\n}\n\n// PythonTeacher class implementing Teacher\nclass PythonTeacher extends Teacher {\n    @Override\n    void teach() {\n        System.out.println("Teaching Python programming");\n    }\n    \n    @Override\n    void project() {\n        System.out.println("Guiding Python project");\n    }\n}\n\n// Main class - TeacherApp\npublic class TeacherApp {\n    // Static method to demonstrate teacher behavior\n    static void teacherBehavior(Teacher teacher) {\n        teacher.teach();\n        teacher.project();\n    }\n    \n    public static void main(String[] args) {\n        // Creating objects of JavaTeacher and PythonTeacher\n        Teacher javaTeacher = new JavaTeacher();\n        Teacher pythonTeacher = new PythonTeacher();\n        \n        // Calling static method with different teacher types\n        teacherBehavior(javaTeacher);\n        teacherBehavior(pythonTeacher);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"4-explanation-of-the-code",children:(0,a.jsx)(n.strong,{children:"4. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Abstract Class ",(0,a.jsx)(n.code,{children:"Teacher"})]}),": Defines abstract methods ",(0,a.jsx)(n.code,{children:"teach()"})," and ",(0,a.jsx)(n.code,{children:"project()"}),", which must be implemented by subclasses."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Concrete Classes ",(0,a.jsx)(n.code,{children:"JavaTeacher"})," and ",(0,a.jsx)(n.code,{children:"PythonTeacher"})]}),": Extend ",(0,a.jsx)(n.code,{children:"Teacher"})," and provide implementations for ",(0,a.jsx)(n.code,{children:"teach()"})," and ",(0,a.jsx)(n.code,{children:"project()"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Static Method ",(0,a.jsx)(n.code,{children:"teacherBehavior()"})]}),": Accepts a ",(0,a.jsx)(n.code,{children:"Teacher"})," object and calls its methods, demonstrating polymorphism."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Main Method Execution"}),":","\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Creates instances of ",(0,a.jsx)(n.code,{children:"JavaTeacher"})," and ",(0,a.jsx)(n.code,{children:"PythonTeacher"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Calls ",(0,a.jsx)(n.code,{children:"teacherBehavior()"})," to execute their methods."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"5-key-takeaways",children:(0,a.jsx)(n.strong,{children:"5. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstraction"})," helps in designing flexible and reusable code."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstract classes"})," allow defining common functionality while forcing subclasses to implement specific behaviors."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static methods"})," can be used to handle different object types polymorphically."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Abstraction reduces code complexity by exposing only relevant details."})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"pure-and-impure-abstract-classes-in-java",children:(0,a.jsx)(n.strong,{children:"Pure and Impure Abstract Classes in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-what-is-an-abstract-class",children:(0,a.jsx)(n.strong,{children:"1. What is an Abstract Class?"})}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.strong,{children:"abstract class"})," is a class that cannot be instantiated and may contain ",(0,a.jsx)(n.strong,{children:"abstract methods"})," (methods without a body) as well as ",(0,a.jsx)(n.strong,{children:"concrete methods"})," (methods with a body)."]}),"\n",(0,a.jsx)(n.h4,{id:"2-types-of-abstract-classes",children:(0,a.jsx)(n.strong,{children:"2. Types of Abstract Classes"})}),"\n",(0,a.jsx)(n.h5,{id:"a-pure-abstract-class",children:(0,a.jsx)(n.strong,{children:"(A) Pure Abstract Class"})}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.strong,{children:"pure abstract class"})," is an abstract class where ",(0,a.jsx)(n.strong,{children:"all methods are abstract"})," (i.e., have no body)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Pure Abstract Class\nabstract class Program1 {\n    abstract void display1();\n    abstract void display2();\n}\n"})}),"\n",(0,a.jsx)(n.h5,{id:"b-impure-abstract-class-type-1",children:(0,a.jsx)(n.strong,{children:"(B) Impure Abstract Class (Type 1)"})}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.strong,{children:"impure abstract class"})," is an abstract class that contains ",(0,a.jsx)(n.strong,{children:"at least one abstract method and at least one concrete method"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Impure Abstract Class with one abstract and one concrete method\nabstract class Program2 {\n    abstract void display1(); // Abstract method\n    \n    void display2() { // Concrete method\n        System.out.println("Inside concrete method display2()");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h5,{id:"c-impure-abstract-class-type-2",children:(0,a.jsx)(n.strong,{children:"(C) Impure Abstract Class (Type 2)"})}),"\n",(0,a.jsxs)(n.p,{children:["Another type of impure abstract class where ",(0,a.jsx)(n.strong,{children:"both methods are concrete"})," but the class is still abstract."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Impure Abstract Class with all concrete methods\nabstract class Program3 {\n    void display1() {\n        System.out.println("Inside concrete method display1()");\n    }\n    \n    void display2() {\n        System.out.println("Inside concrete method display2()");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-why-cant-abstract-classes-be-instantiated",children:(0,a.jsx)(n.strong,{children:"3. Why Can't Abstract Classes Be Instantiated?"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["An ",(0,a.jsx)(n.strong,{children:"abstract class is incomplete"})," because it may have abstract methods that do not have an implementation."]}),"\n",(0,a.jsx)(n.li,{children:"If an object is created for an abstract class, it would not be able to call abstract methods as they have no body."}),"\n",(0,a.jsxs)(n.li,{children:["Instead, ",(0,a.jsx)(n.strong,{children:"abstract classes must be inherited by a subclass"}),", which provides implementations for abstract methods."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-example-demonstrating-instantiation-restriction",children:(0,a.jsx)(n.strong,{children:"4. Example Demonstrating Instantiation Restriction"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"abstract class Example {\n    abstract void show(); // Abstract method\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // Example obj = new Example(); // Error! Abstract classes cannot be instantiated\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"5-key-takeaways-1",children:(0,a.jsx)(n.strong,{children:"5. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"A pure abstract class"})," has only abstract methods."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"An impure abstract class"})," has a mix of abstract and concrete methods."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstract classes cannot be instantiated"})," but can be used as a base class for inheritance."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Subclasses must implement abstract methods"})," before they can be instantiated."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Concrete methods in an abstract class provide shared functionality"})," without requiring every subclass to implement them."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"partial-abstraction-in-java",children:(0,a.jsx)(n.strong,{children:"Partial Abstraction in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-what-is-partial-abstraction",children:(0,a.jsx)(n.strong,{children:"1. What is Partial Abstraction?"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["If a child class ",(0,a.jsx)(n.strong,{children:"inherits"})," an abstract class that contains abstract methods, the child class ",(0,a.jsx)(n.strong,{children:"must override all abstract methods"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["If the child class does ",(0,a.jsx)(n.strong,{children:"not"})," provide implementations for all abstract methods, it must be declared ",(0,a.jsx)(n.strong,{children:"abstract"})," as well."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.strong,{children:"partially abstract class"})," is an abstract class that implements some but not all of its abstract methods."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-of-partial-abstraction",children:(0,a.jsx)(n.strong,{children:"2. Example of Partial Abstraction"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Abstract class Vehicle\nabstract class Vehicle {\n    abstract void speed();  // Abstract method\n    abstract void seater(); // Abstract method\n}\n\n// Abstract class Car extending Vehicle (Partial Abstraction)\nabstract class Car extends Vehicle {\n    @Override\n    void speed() { // Implementing only speed method\n        System.out.println("Car has a speed limit of 200 km/h");\n    }\n    // \'seater()\' is not implemented, so Car remains abstract\n}\n\n// Concrete class Bike extending Vehicle (Full Implementation)\nclass Bike extends Vehicle {\n    @Override\n    void speed() {\n        System.out.println("Bike has a speed limit of 150 km/h");\n    }\n    \n    @Override\n    void seater() {\n        System.out.println("Bike is a 2-seater");\n    }\n}\n\n// Main class\npublic class VehicleApp {\n    public static void main(String[] args) {\n        // Vehicle vehicle = new Vehicle(); // Error! Abstract classes cannot be instantiated\n        // Car car = new Car(); // Error! Abstract classes cannot be instantiated\n        \n        Bike bike = new Bike(); // Creating an instance of Bike\n        bike.speed();  // Calls speed method\n        bike.seater(); // Calls seater method\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Abstract Class ",(0,a.jsx)(n.code,{children:"Vehicle"})]}),": Contains two abstract methods ",(0,a.jsx)(n.code,{children:"speed()"})," and ",(0,a.jsx)(n.code,{children:"seater()"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Partial Abstract Class ",(0,a.jsx)(n.code,{children:"Car"})]}),": Implements only the ",(0,a.jsx)(n.code,{children:"speed()"})," method but not ",(0,a.jsx)(n.code,{children:"seater()"}),", so it remains abstract."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Concrete Class ",(0,a.jsx)(n.code,{children:"Bike"})]}),": Implements both ",(0,a.jsx)(n.code,{children:"speed()"})," and ",(0,a.jsx)(n.code,{children:"seater()"}),", making it a complete class."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Instantiation Rules"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstract classes cannot be instantiated"})," (",(0,a.jsx)(n.code,{children:"new Vehicle()"})," and ",(0,a.jsx)(n.code,{children:"new Car()"})," would cause errors)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Concrete classes must implement all abstract methods"})," before they can be instantiated."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Partial abstraction allows abstract classes to provide some implementations while leaving others for subclasses."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"If a child class does not implement all abstract methods, it must also be declared abstract."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Concrete subclasses must provide implementations for all inherited abstract methods."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Abstract classes help in designing a flexible and reusable object-oriented structure."})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"restrictions-on-abstract-methods-in-java",children:(0,a.jsx)(n.strong,{children:"Restrictions on Abstract Methods in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-why-cant-abstract-methods-be-final-or-static",children:(0,a.jsxs)(n.strong,{children:["1. Why Can't Abstract Methods Be ",(0,a.jsx)(n.code,{children:"final"})," or ",(0,a.jsx)(n.code,{children:"static"}),"?"]})}),"\n",(0,a.jsx)(n.h5,{id:"a-abstract-methods-cannot-be-final",children:(0,a.jsxs)(n.strong,{children:["(A) Abstract Methods Cannot Be ",(0,a.jsx)(n.code,{children:"final"})]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["An ",(0,a.jsx)(n.strong,{children:"abstract method"})," must be ",(0,a.jsx)(n.strong,{children:"overridden"})," by a subclass to provide its implementation."]}),"\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"final"})," method cannot be overridden"]}),", which contradicts the purpose of an abstract method."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Opposing Statements"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Abstract methods ",(0,a.jsx)(n.strong,{children:"must be overridden"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Final methods ",(0,a.jsx)(n.strong,{children:"cannot be overridden"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["This conflict makes it ",(0,a.jsx)(n.strong,{children:"impossible"})," to declare an abstract method as ",(0,a.jsx)(n.code,{children:"final"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h5,{id:"b-abstract-methods-cannot-be-static",children:(0,a.jsxs)(n.strong,{children:["(B) Abstract Methods Cannot Be ",(0,a.jsx)(n.code,{children:"static"})]})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.strong,{children:"static method belongs to a class"}),", not an instance."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstract methods are meant to be implemented in subclasses"}),", but a ",(0,a.jsx)(n.code,{children:"static"})," method cannot be overridden."]}),"\n",(0,a.jsxs)(n.li,{children:["This means declaring an abstract method as ",(0,a.jsx)(n.code,{children:"static"})," contradicts its purpose."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-demonstrating-errors",children:(0,a.jsx)(n.strong,{children:"2. Example Demonstrating Errors"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Abstract class Vehicle\nabstract class Vehicle {\n    // Valid final method (Concrete method in abstract class)\n    final void speed() {\n        System.out.println("Speed limit is 100 km/h");\n    }\n    \n    // Invalid: Abstract methods cannot be final\n    // abstract final void seater(); // ERROR\n    \n    // Invalid: Abstract methods cannot be static\n    // abstract static void typeEngine(); // ERROR\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-errors",children:(0,a.jsx)(n.strong,{children:"3. Explanation of Errors"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"final"})," method ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"speed()"})})," is valid because it has a body and cannot be overridden."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"abstract final void seater();"})," ",(0,a.jsx)(n.strong,{children:"causes an error"})," because abstract methods must be overridden, but final methods cannot be."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"abstract static void typeEngine();"})," ",(0,a.jsx)(n.strong,{children:"causes an error"})," because static methods belong to a class and cannot be overridden."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-1",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Abstract methods cannot be ",(0,a.jsx)(n.code,{children:"final"})]})," because they must be overridden."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Abstract methods cannot be ",(0,a.jsx)(n.code,{children:"static"})]})," because static methods belong to the class and cannot be overridden."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Abstract classes can contain ",(0,a.jsx)(n.code,{children:"final"})," or ",(0,a.jsx)(n.code,{children:"static"})," concrete methods"]}),", but not abstract ones."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Using abstract methods correctly ensures proper inheritance and polymorphism in Java."})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"understanding-static-and-non-static-members-in-an-abstract-class",children:(0,a.jsx)(n.strong,{children:"Understanding Static and Non-Static Members in an Abstract Class"})}),"\n",(0,a.jsx)(n.h4,{id:"1-components-of-an-abstract-class",children:(0,a.jsx)(n.strong,{children:"1. Components of an Abstract Class"})}),"\n",(0,a.jsx)(n.p,{children:"An abstract class in Java can contain:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static variables"}),": Shared among all instances of the class."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static methods"}),": Can be called without creating an object."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static blocks"}),": Executed once when the class is loaded."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Non-static (instance) variables"}),": Belong to an instance of the class."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Non-static blocks"}),": Execute when an object is created, before the constructor."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Constructors"}),": Used to initialize instance variables."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstract methods"}),": Must be implemented by subclasses."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-of-an-abstract-class-with-static-and-non-static-members",children:(0,a.jsx)(n.strong,{children:"2. Example of an Abstract Class with Static and Non-Static Members"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Abstract class Vehicle\nabstract class Vehicle {\n    static int x; // Static variable\n    int y; // Non-static variable\n    \n    // Static block (Executes when class loads)\n    static {\n        System.out.println("Inside static block");\n        x = 10;\n    }\n    \n    // Static method (Can be called without an object)\n    static void display1() {\n        System.out.println("Inside static method display1()");\n        System.out.println("Value of x: " + x);\n    }\n    \n    // Non-static block (Executes before constructor when an object is created)\n    {\n        System.out.println("Inside non-static block");\n        y = 20;\n    }\n    \n    // Constructor\n    Vehicle() {\n        System.out.println("Inside Vehicle constructor");\n    }\n    \n    // Non-static method\n    void display2() {\n        System.out.println("Inside non-static method display2()");\n        System.out.println("Value of x: " + x);\n        System.out.println("Value of y: " + y);\n    }\n    \n    // Abstract method (Must be implemented by subclasses)\n    abstract void display3();\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code-1",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Static Variable ",(0,a.jsx)(n.code,{children:"x"})]}),": Initialized in the static block and shared across all objects."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static Block"}),": Executes once when the class is loaded."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Static Method ",(0,a.jsx)(n.code,{children:"display1()"})]}),": Prints the value of ",(0,a.jsx)(n.code,{children:"x"})," and can be called without an object."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Non-static Variable ",(0,a.jsx)(n.code,{children:"y"})]}),": Initialized in the non-static block."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Non-static Block"}),": Runs when an object is created, before the constructor."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Constructor"}),": Runs when an object is instantiated."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Non-static Method ",(0,a.jsx)(n.code,{children:"display2()"})]}),": Prints values of ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Abstract Method ",(0,a.jsx)(n.code,{children:"display3()"})]}),": Must be implemented by a subclass."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-2",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static members belong to the class"}),", whereas ",(0,a.jsx)(n.strong,{children:"non-static members belong to instances"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static blocks execute once when the class is loaded"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Non-static blocks execute before the constructor when an object is created"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstract methods must be implemented in subclasses"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static methods cannot access non-static variables directly"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Static methods can be called without an instance, but non-static methods require an object"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This structure ensures better understanding and organization of Java classes containing static and non-static members."}),"\n",(0,a.jsx)(n.h3,{id:"abstraction-using-interfaces-in-java",children:(0,a.jsx)(n.strong,{children:"Abstraction Using Interfaces in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-what-is-an-interface",children:(0,a.jsx)(n.strong,{children:"1. What is an Interface?"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["An ",(0,a.jsx)(n.strong,{children:"interface"})," consists only of ",(0,a.jsx)(n.strong,{children:"abstract methods"})," (prior to Java 8)."]}),"\n",(0,a.jsxs)(n.li,{children:["It is another way of achieving ",(0,a.jsx)(n.strong,{children:"abstraction"})," in Java."]}),"\n",(0,a.jsxs)(n.li,{children:["A class that implements an interface must provide implementations for all abstract methods ",(0,a.jsx)(n.strong,{children:"or"})," be declared abstract."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:[(0,a.jsx)(n.code,{children:"implements"})," keyword"]})," is used by a class to inherit an interface."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-of-abstraction-using-an-interface",children:(0,a.jsx)(n.strong,{children:"2. Example of Abstraction Using an Interface"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Interface defining student activities\ninterface StudentActivities {\n    void study();    // Abstract method\n    void practice(); // Abstract method\n}\n\n// Class implementing StudentActivities interface for Physics student\nclass PhysicsStudent implements StudentActivities {\n    @Override\n    public void study() {\n        System.out.println("Physics student is studying Physics concepts.");\n    }\n    \n    @Override\n    public void practice() {\n        System.out.println("Physics student is solving numerical problems.");\n    }\n}\n\n// Class implementing StudentActivities interface for Math student\nclass MathStudent implements StudentActivities {\n    @Override\n    public void study() {\n        System.out.println("Math student is studying algebra and calculus.");\n    }\n    \n    @Override\n    public void practice() {\n        System.out.println("Math student is solving equations and proofs.");\n    }\n}\n\n// Main class with static method to invoke student activities\npublic class StudentApp {\n    static void invokeStudentActivity(StudentActivities student) {\n        student.study();\n        student.practice();\n    }\n    \n    public static void main(String[] args) {\n        PhysicsStudent physicsStudent = new PhysicsStudent();\n        MathStudent mathStudent = new MathStudent();\n        \n        System.out.println("Physics Student Activities:");\n        invokeStudentActivity(physicsStudent);\n        \n        System.out.println("\\nMath Student Activities:");\n        invokeStudentActivity(mathStudent);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code-2",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface ",(0,a.jsx)(n.code,{children:"StudentActivities"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Declares two abstract methods: ",(0,a.jsx)(n.code,{children:"study()"})," and ",(0,a.jsx)(n.code,{children:"practice()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"PhysicsStudent"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements the ",(0,a.jsx)(n.code,{children:"StudentActivities"})," interface."]}),"\n",(0,a.jsxs)(n.li,{children:["Provides concrete implementations for ",(0,a.jsx)(n.code,{children:"study()"})," and ",(0,a.jsx)(n.code,{children:"practice()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"MathStudent"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements the ",(0,a.jsx)(n.code,{children:"StudentActivities"})," interface."]}),"\n",(0,a.jsxs)(n.li,{children:["Provides concrete implementations for ",(0,a.jsx)(n.code,{children:"study()"})," and ",(0,a.jsx)(n.code,{children:"practice()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Static Method ",(0,a.jsx)(n.code,{children:"invokeStudentActivity(StudentActivities student)"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Calls ",(0,a.jsx)(n.code,{children:"study()"})," and ",(0,a.jsx)(n.code,{children:"practice()"})," on any object that implements ",(0,a.jsx)(n.code,{children:"StudentActivities"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Main Method"}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Creates instances of ",(0,a.jsx)(n.code,{children:"PhysicsStudent"})," and ",(0,a.jsx)(n.code,{children:"MathStudent"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Calls ",(0,a.jsx)(n.code,{children:"invokeStudentActivity()"})," for both students."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-3",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Interfaces in Java help achieve abstraction"})," by enforcing method implementation."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"A class implementing an interface must provide method bodies for all abstract methods."})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Interfaces promote loose coupling"})," and enable multiple inheritance."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Static methods in a separate class can be used to invoke interface methods dynamically."})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"why-were-interfaces-introduced-in-java",children:(0,a.jsx)(n.strong,{children:"Why Were Interfaces Introduced in Java?"})}),"\n",(0,a.jsx)(n.h4,{id:"1-reasons-for-introducing-interfaces",children:(0,a.jsx)(n.strong,{children:"1. Reasons for Introducing Interfaces"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Standardization"}),": Interfaces provide method declarations only, ensuring that implementing classes follow a standard structure. Interfaces specify ",(0,a.jsx)(n.strong,{children:"what to do"}),", not ",(0,a.jsx)(n.strong,{children:"how to do it"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multiple Inheritance"}),": Java does not support multiple inheritance with classes, but ",(0,a.jsx)(n.strong,{children:"multiple inheritance can be achieved using interfaces"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No Default Parent"}),": Unlike classes, interfaces do not extend any parent class by default, making them more flexible."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Object Instantiation Restriction"}),": Objects of an interface ",(0,a.jsx)(n.strong,{children:"cannot be created"}),", but ",(0,a.jsx)(n.strong,{children:"interface references"})," can be used to hold objects of implementing classes."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-of-interface-usage-in-java",children:(0,a.jsx)(n.strong,{children:"2. Example of Interface Usage in Java"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Define an interface with method declarations\ninterface Calculator {\n    void add(int a, int b);\n    void subtract(int a, int b);\n}\n\n// Implementing the interface in a class\nclass MyCalculator implements Calculator {\n    @Override\n    public void add(int a, int b) {\n        System.out.println("Sum: " + (a + b));\n    }\n    \n    @Override\n    public void subtract(int a, int b) {\n        System.out.println("Difference: " + (a - b));\n    }\n}\n\n// Main class\npublic class CalculatorApp {\n    public static void main(String[] args) {\n        // Interface reference holding an object of implementing class\n        Calculator calc = new MyCalculator();\n        \n        // Calling methods using interface reference\n        calc.add(10, 5);\n        calc.subtract(10, 5);\n        \n        // Trying to create an object of interface (Not Allowed)\n        // Calculator obj = new Calculator(); // Error: Cannot instantiate an interface\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code-3",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface ",(0,a.jsx)(n.code,{children:"Calculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Declares ",(0,a.jsx)(n.code,{children:"add()"})," and ",(0,a.jsx)(n.code,{children:"subtract()"})," methods."]}),"\n",(0,a.jsxs)(n.li,{children:["Methods are ",(0,a.jsx)(n.strong,{children:"implicitly public and abstract"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"MyCalculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements ",(0,a.jsx)(n.code,{children:"Calculator"})," interface."]}),"\n",(0,a.jsxs)(n.li,{children:["Provides concrete implementations for ",(0,a.jsx)(n.code,{children:"add()"})," and ",(0,a.jsx)(n.code,{children:"subtract()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Main Class ",(0,a.jsx)(n.code,{children:"CalculatorApp"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Creates an ",(0,a.jsx)(n.strong,{children:"interface reference"})," (",(0,a.jsx)(n.code,{children:"Calculator calc"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:["Assigns an object of ",(0,a.jsx)(n.code,{children:"MyCalculator"})," to the interface reference."]}),"\n",(0,a.jsx)(n.li,{children:"Calls methods using the interface reference."}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Demonstrates that an object of an interface cannot be created."})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-4",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Interfaces ensure standardization"})," by defining method declarations."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multiple inheritance is possible"})," because a class can implement multiple interfaces."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"An interface cannot have an object"}),", but ",(0,a.jsx)(n.strong,{children:"an interface reference can hold an object of an implementing class"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"All methods in an interface are public and abstract by default"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"interface-methods-and-variables-in-java",children:(0,a.jsx)(n.strong,{children:"Interface Methods and Variables in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-key-properties-of-interfaces",children:(0,a.jsx)(n.strong,{children:"1. Key Properties of Interfaces"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["All methods in an interface are implicitly ",(0,a.jsx)(n.code,{children:"public"})," and ",(0,a.jsx)(n.code,{children:"abstract"})]}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["All variables in an interface are implicitly ",(0,a.jsx)(n.code,{children:"public"}),", ",(0,a.jsx)(n.code,{children:"static"}),", and ",(0,a.jsx)(n.code,{children:"final"})]}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Since interface variables are ",(0,a.jsx)(n.code,{children:"final"}),", they must be initialized at the time of declaration"]}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-program-implementing-an-interface",children:(0,a.jsx)(n.strong,{children:"2. Example Program: Implementing an Interface"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Define an interface with method declarations\ninterface Calculator {\n    int A = 10; // Implicitly public, static, and final\n    public static final int B = 20; // Explicitly declared public, static, final\n    // int C; // Error: Variable \'C\' must be initialized\n    \n    void add(int a, int b);\n    void subtract(int a, int b);\n    void multiply(int a, int b);\n}\n\n// Implementing the interface in a class\nclass MyCalculator implements Calculator {\n    @Override\n    public void add(int a, int b) {\n        System.out.println("Sum: " + (a + b));\n    }\n    \n    @Override\n    public void subtract(int a, int b) {\n        System.out.println("Difference: " + (a - b));\n    }\n    \n    @Override\n    public void multiply(int a, int b) {\n        System.out.println("Product: " + (a * b));\n    }\n    \n    // Attempting to modify a final variable (Will Cause an Error)\n    // { A = 99; } // Error: final variable cannot be reassigned\n}\n\n// Main class\npublic class CalculatorApp {\n    public static void main(String[] args) {\n        // Accessing interface variables\n        System.out.println("Value of A: " + Calculator.A);\n        System.out.println("Value of B: " + Calculator.B);\n        \n        // Creating an object of MyCalculator\n        Calculator calc = new MyCalculator();\n        \n        // Calling methods using interface reference\n        calc.add(10, 5);\n        calc.subtract(10, 5);\n        calc.multiply(10, 5);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code-4",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface ",(0,a.jsx)(n.code,{children:"Calculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Declares three methods: ",(0,a.jsx)(n.code,{children:"add()"}),", ",(0,a.jsx)(n.code,{children:"subtract()"}),", and ",(0,a.jsx)(n.code,{children:"multiply()"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Defines variables ",(0,a.jsx)(n.code,{children:"A"})," and ",(0,a.jsx)(n.code,{children:"B"})," as ",(0,a.jsx)(n.code,{children:"public static final"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"C"})," is commented out because it would cause an error since interface variables ",(0,a.jsx)(n.strong,{children:"must be initialized"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"MyCalculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements the ",(0,a.jsx)(n.code,{children:"Calculator"})," interface."]}),"\n",(0,a.jsx)(n.li,{children:"Provides concrete implementations for all three methods."}),"\n",(0,a.jsxs)(n.li,{children:["Attempts to modify ",(0,a.jsx)(n.code,{children:"A"}),", which causes an ",(0,a.jsx)(n.strong,{children:"error"})," because interface variables are ",(0,a.jsx)(n.strong,{children:"final"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Main Class ",(0,a.jsx)(n.code,{children:"CalculatorApp"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Accesses interface variables directly using ",(0,a.jsx)(n.code,{children:"Calculator.A"})," and ",(0,a.jsx)(n.code,{children:"Calculator.B"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Creates an object of ",(0,a.jsx)(n.code,{children:"MyCalculator"})," using an interface reference."]}),"\n",(0,a.jsxs)(n.li,{children:["Calls ",(0,a.jsx)(n.code,{children:"add()"}),", ",(0,a.jsx)(n.code,{children:"subtract()"}),", and ",(0,a.jsx)(n.code,{children:"multiply()"})," methods."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-5",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface methods are always ",(0,a.jsx)(n.code,{children:"public"})," and ",(0,a.jsx)(n.code,{children:"abstract"})]})," (even if not explicitly mentioned)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface variables are always ",(0,a.jsx)(n.code,{children:"public"}),", ",(0,a.jsx)(n.code,{children:"static"}),", and ",(0,a.jsx)(n.code,{children:"final"})]}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Final variables must be initialized at the time of declaration"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Final variables cannot be reassigned once initialized"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Interfaces provide a contract that implementing classes must follow"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"partial-implementation-of-an-interface-in-java",children:(0,a.jsx)(n.strong,{children:"Partial Implementation of an Interface in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-key-concept",children:(0,a.jsx)(n.strong,{children:"1. Key Concept"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["When a class implements an interface, it ",(0,a.jsx)(n.strong,{children:"must provide implementations"})," for ",(0,a.jsx)(n.strong,{children:"all"})," abstract methods of the interface."]}),"\n",(0,a.jsxs)(n.li,{children:["If a class does ",(0,a.jsx)(n.strong,{children:"not"})," provide implementations for all abstract methods, it must be declared as an ",(0,a.jsx)(n.strong,{children:"abstract class"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Abstract classes cannot be instantiated directly."}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-program-partial-implementation-of-an-interface",children:(0,a.jsx)(n.strong,{children:"2. Example Program: Partial Implementation of an Interface"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Define an interface with method declarations\ninterface Calculator {\n    void add(int a, int b);\n    void subtract(int a, int b);\n}\n\n// Partial implementation of the interface\nabstract class PartialCalculator implements Calculator {\n    @Override\n    public void add(int a, int b) {\n        System.out.println("Sum: " + (a + b));\n    }\n    \n    // No implementation for subtract(), so the class remains abstract\n}\n\n// Full implementation of the interface\nclass MyCalculator extends PartialCalculator {\n    @Override\n    public void subtract(int a, int b) {\n        System.out.println("Difference: " + (a - b));\n    }\n}\n\n// Main class\npublic class CalculatorApp {\n    public static void main(String[] args) {\n        // PartialCalculator calc = new PartialCalculator(); // Error: Cannot instantiate an abstract class\n        Calculator calc = new MyCalculator(); // Using full implementation\n        calc.add(10, 5);\n        calc.subtract(10, 5);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code-5",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface ",(0,a.jsx)(n.code,{children:"Calculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Declares ",(0,a.jsx)(n.code,{children:"add()"})," and ",(0,a.jsx)(n.code,{children:"subtract()"})," methods."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"PartialCalculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements ",(0,a.jsx)(n.code,{children:"add()"})," method."]}),"\n",(0,a.jsxs)(n.li,{children:["Does ",(0,a.jsx)(n.strong,{children:"not"})," provide an implementation for ",(0,a.jsx)(n.code,{children:"subtract()"}),", so it is declared as ",(0,a.jsx)(n.strong,{children:"abstract"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Cannot be instantiated directly."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"MyCalculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Extends ",(0,a.jsx)(n.code,{children:"PartialCalculator"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Provides implementation for ",(0,a.jsx)(n.code,{children:"subtract()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Main Class ",(0,a.jsx)(n.code,{children:"CalculatorApp"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Cannot create an object of ",(0,a.jsx)(n.code,{children:"PartialCalculator"})," (since it is abstract)."]}),"\n",(0,a.jsxs)(n.li,{children:["Uses ",(0,a.jsx)(n.code,{children:"MyCalculator"})," to access both methods."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-6",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.strong,{children:"class must implement all abstract methods"})," from an interface."]}),"\n",(0,a.jsxs)(n.li,{children:["If a class provides only a ",(0,a.jsx)(n.strong,{children:"partial implementation"}),", it must be declared ",(0,a.jsx)(n.strong,{children:"abstract"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Abstract classes ",(0,a.jsx)(n.strong,{children:"cannot be instantiated"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["A subclass must implement any remaining abstract methods to become ",(0,a.jsx)(n.strong,{children:"fully concrete"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"achieving-multiple-inheritance-using-interfaces-in-java",children:(0,a.jsx)(n.strong,{children:"Achieving Multiple Inheritance Using Interfaces in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-key-concept-1",children:(0,a.jsx)(n.strong,{children:"1. Key Concept"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Java does ",(0,a.jsx)(n.strong,{children:"not"})," support multiple inheritance with classes, but it ",(0,a.jsx)(n.strong,{children:"can be achieved using interfaces"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["A class can ",(0,a.jsx)(n.strong,{children:"implement multiple interfaces"})," and provide implementations for their methods."]}),"\n",(0,a.jsxs)(n.li,{children:["This approach allows Java to achieve ",(0,a.jsx)(n.strong,{children:"multiple inheritance without ambiguity"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-program-achieving-multiple-inheritance-with-interfaces",children:(0,a.jsx)(n.strong,{children:"2. Example Program: Achieving Multiple Inheritance with Interfaces"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Define first interface\ninterface Calculator1 {\n    void add(int a, int b);\n}\n\n// Define second interface\ninterface Calculator2 {\n    void subtract(int a, int b);\n}\n\n// Define third interface\ninterface Calculator3 {\n    void multiply(int a, int b);\n}\n\n// Implementing multiple interfaces in a single class\nclass MyCalculator implements Calculator1, Calculator2, Calculator3 {\n    @Override\n    public void add(int a, int b) {\n        System.out.println("Sum: " + (a + b));\n    }\n    \n    @Override\n    public void subtract(int a, int b) {\n        System.out.println("Difference: " + (a - b));\n    }\n    \n    @Override\n    public void multiply(int a, int b) {\n        System.out.println("Product: " + (a * b));\n    }\n}\n\n// Main class\npublic class CalculatorApp {\n    public static void main(String[] args) {\n        // Creating an object of MyCalculator\n        MyCalculator calc = new MyCalculator();\n        \n        // Calling methods\n        calc.add(10, 5);\n        calc.subtract(10, 5);\n        calc.multiply(10, 5);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code-6",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interfaces ",(0,a.jsx)(n.code,{children:"Calculator1"}),", ",(0,a.jsx)(n.code,{children:"Calculator2"}),", and ",(0,a.jsx)(n.code,{children:"Calculator3"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Each interface declares one method (",(0,a.jsx)(n.code,{children:"add()"}),", ",(0,a.jsx)(n.code,{children:"subtract()"}),", and ",(0,a.jsx)(n.code,{children:"multiply()"}),", respectively)."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"MyCalculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implements all three interfaces."}),"\n",(0,a.jsx)(n.li,{children:"Provides concrete implementations for all methods."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Main Class ",(0,a.jsx)(n.code,{children:"CalculatorApp"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Creates an object of ",(0,a.jsx)(n.code,{children:"MyCalculator"}),"."]}),"\n",(0,a.jsx)(n.li,{children:"Calls all implemented methods."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-7",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multiple inheritance is achieved using interfaces"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"A class can implement multiple interfaces"})," and provide concrete implementations."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Each interface defines a specific contract that the implementing class must fulfill"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Using interfaces prevents the common issues of multiple inheritance in traditional OOP languages"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"interface-inheritance-in-java",children:(0,a.jsx)(n.strong,{children:"Interface Inheritance in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-key-concept-2",children:(0,a.jsx)(n.strong,{children:"1. Key Concept"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"An interface cannot implement another interface"}),", but it ",(0,a.jsx)(n.strong,{children:"can extend"})," another interface."]}),"\n",(0,a.jsxs)(n.li,{children:["When an ",(0,a.jsx)(n.strong,{children:"interface extends another interface"}),", the child interface inherits all methods of the parent interface."]}),"\n",(0,a.jsxs)(n.li,{children:["If a ",(0,a.jsx)(n.strong,{children:"class implements the child interface"}),", it must provide implementations for ",(0,a.jsx)(n.strong,{children:"all methods of both the child and parent interfaces"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-program-interface-extending-another-interface",children:(0,a.jsx)(n.strong,{children:"2. Example Program: Interface Extending Another Interface"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Parent interface\ninterface Calculator1 {\n    void add(int a, int b);\n}\n\n// Child interface extending the parent interface\ninterface Calculator2 extends Calculator1 {\n    void subtract(int a, int b);\n}\n\n// Class implementing the child interface\nclass MyCalculator implements Calculator2 {\n    @Override\n    public void add(int a, int b) {\n        System.out.println("Sum: " + (a + b));\n    }\n    \n    @Override\n    public void subtract(int a, int b) {\n        System.out.println("Difference: " + (a - b));\n    }\n}\n\n// Main class\npublic class CalculatorApp {\n    public static void main(String[] args) {\n        // Creating an object of MyCalculator\n        MyCalculator calc = new MyCalculator();\n        \n        // Calling methods\n        calc.add(10, 5);\n        calc.subtract(10, 5);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-explanation-of-the-code-7",children:(0,a.jsx)(n.strong,{children:"3. Explanation of the Code"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface ",(0,a.jsx)(n.code,{children:"Calculator1"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Declares ",(0,a.jsx)(n.code,{children:"add()"})," method."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Interface ",(0,a.jsx)(n.code,{children:"Calculator2"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Extends ",(0,a.jsx)(n.code,{children:"Calculator1"})]}),", inheriting the ",(0,a.jsx)(n.code,{children:"add()"})," method."]}),"\n",(0,a.jsxs)(n.li,{children:["Declares an additional ",(0,a.jsx)(n.code,{children:"subtract()"})," method."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Class ",(0,a.jsx)(n.code,{children:"MyCalculator"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Implements ",(0,a.jsx)(n.code,{children:"Calculator2"}),", which means it ",(0,a.jsxs)(n.strong,{children:["must provide implementations for both ",(0,a.jsx)(n.code,{children:"add()"})," and ",(0,a.jsx)(n.code,{children:"subtract()"})]}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Main Class ",(0,a.jsx)(n.code,{children:"CalculatorApp"})]}),":","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Creates an object of ",(0,a.jsx)(n.code,{children:"MyCalculator"})," and calls both methods."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"4-key-takeaways-8",children:(0,a.jsx)(n.strong,{children:"4. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"An interface can extend another interface"})," to inherit its methods."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"A class implementing a child interface must implement all methods of both child and parent interfaces"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"This mechanism supports code reusability and standardization in Java"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"interface-inheritance-in-java-1",children:(0,a.jsx)(n.strong,{children:"Interface Inheritance in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-key-concept-3",children:(0,a.jsx)(n.strong,{children:"1. Key Concept"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"An interface cannot implement another interface"}),", but it ",(0,a.jsx)(n.strong,{children:"can extend"})," another interface."]}),"\n",(0,a.jsxs)(n.li,{children:["When an ",(0,a.jsx)(n.strong,{children:"interface extends another interface"}),", the child interface inherits all methods of the parent interface."]}),"\n",(0,a.jsxs)(n.li,{children:["If a ",(0,a.jsx)(n.strong,{children:"class implements the child interface"}),", it must provide implementations for ",(0,a.jsx)(n.strong,{children:"all methods of both the child and parent interfaces"}),"."]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"A class can extend another class and implement an interface at the same time."})}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-program-class-extending-another-class-and-implementing-an-interface",children:(0,a.jsx)(n.strong,{children:"2. Example Program: Class Extending Another Class and Implementing an Interface"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Parent class\nclass BasicCalculator {\n    void multiply(int a, int b) {\n        System.out.println("Product: " + (a * b));\n    }\n}\n\n// Interface\ninterface Calculator {\n    void add(int a, int b);\n}\n\n// Class extending another class and implementing an interface\nclass AdvancedCalculator extends BasicCalculator implements Calculator {\n    public void add(int a, int b) {\n        System.out.println("Sum: " + (a + b));\n    }\n}\n\n// Main class\npublic class CalculatorApp {\n    public static void main(String[] args) {\n        AdvancedCalculator calc = new AdvancedCalculator();\n        calc.add(10, 5);\n        calc.multiply(10, 5);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-key-takeaways",children:(0,a.jsx)(n.strong,{children:"3. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"A class can extend another class while also implementing an interface."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"This allows the class to inherit concrete methods from the parent class and provide implementations for abstract methods from the interface."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"This mechanism supports both inheritance and interface-based abstraction, making the code more flexible and reusable."})}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"marker-tag-interface-in-java",children:(0,a.jsx)(n.strong,{children:"Marker (Tag) Interface in Java"})}),"\n",(0,a.jsx)(n.h4,{id:"1-key-concept-4",children:(0,a.jsx)(n.strong,{children:"1. Key Concept"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["A ",(0,a.jsx)(n.strong,{children:"marker interface"})," (also called a ",(0,a.jsx)(n.strong,{children:"tag interface"}),") is an ",(0,a.jsx)(n.strong,{children:"empty interface"})," that does not contain any method declarations."]}),"\n",(0,a.jsx)(n.li,{children:"Marker interfaces are used to signal metadata or specific behavior to the JVM or other classes."}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.strong,{children:"Serializable"})," interface is a built-in marker interface in Java."]}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-of-a-marker-interface",children:(0,a.jsx)(n.strong,{children:"2. Example of a Marker Interface"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Marker Interface\ninterface Marker {}\n\n// Class implementing Marker Interface\nclass SachinTendulkar implements Marker {\n    void showPlayer() {\n        System.out.println("Sachin Tendulkar is a legendary cricketer.");\n    }\n}\n\n// Main class\npublic class MarkerExample {\n    public static void main(String[] args) {\n        SachinTendulkar player = new SachinTendulkar();\n        if (player instanceof Marker) {\n            System.out.println("This class is marked with Marker interface.");\n        }\n        player.showPlayer();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-key-takeaways-1",children:(0,a.jsx)(n.strong,{children:"3. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Marker interfaces do not contain any methods."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"They are used to indicate that a class belongs to a specific category."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.strong,{children:["The ",(0,a.jsx)(n.code,{children:"instanceof"})," operator is commonly used to check if an object belongs to a marker interface."]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.strong,{children:["Examples of built-in marker interfaces in Java: ",(0,a.jsx)(n.code,{children:"Serializable"}),", ",(0,a.jsx)(n.code,{children:"Cloneable"}),", ",(0,a.jsx)(n.code,{children:"Remote"}),"."]})}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"2-example-program-interface-with-various-methods",children:(0,a.jsx)(n.strong,{children:"2. Example Program: Interface with Various Methods"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'interface ExampleInterface {\n    // Abstract method (public & abstract by default)\n    void displayOne();\n    \n    // Default concrete method\n    default void displayTwo() {\n        System.out.println("Inside default method displayTwo()");\n    }\n    \n    // Static concrete method\n    static void displayThree() {\n        System.out.println("Inside static method displayThree()");\n    }\n    \n    // Private concrete method (can only be used inside the interface)\n    private void displayFour() {\n        System.out.println("Inside private method displayFour()");\n    }\n}\n\n// Implementing the interface\nclass MyClass implements ExampleInterface {\n    public void displayOne() {\n        System.out.println("Implementing abstract method displayOne()");\n    }\n}\n\n// Main class\npublic class InterfaceExample {\n    public static void main(String[] args) {\n        MyClass obj = new MyClass();\n        obj.displayOne();  // Calling abstract method\n        obj.displayTwo();  // Calling default method\n        ExampleInterface.displayThree(); // Calling static method\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"3-key-takeaways-2",children:(0,a.jsx)(n.strong,{children:"3. Key Takeaways"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Abstract methods must be implemented by the implementing class."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Default methods provide a concrete implementation within the interface."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Static methods can be called using the interface name."})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Private methods are only for internal use within the interface."})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);
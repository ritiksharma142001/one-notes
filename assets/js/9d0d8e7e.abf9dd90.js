"use strict";(self.webpackChunkes_note=self.webpackChunkes_note||[]).push([[2473],{1019:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"advanced-java/0-1/Week-2/2.9","title":"Lamdas & Streams","description":"Introduction to Lambda Expressions","source":"@site/docs/advanced-java/0-1/Week-2/2.9.md","sourceDirName":"advanced-java/0-1/Week-2","slug":"/advanced-java/0-1/Week-2/2.9","permalink":"/one-notes/advanced-java/0-1/Week-2/2.9","draft":false,"unlisted":false,"editUrl":"https://github.com/ritiksharma142001/one-notes/edit/main/docs/advanced-java/0-1/Week-2/2.9.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Transforming API Response","permalink":"/one-notes/advanced-java/0-1/Week-2/2.8"},"next":{"title":"2.10","permalink":"/one-notes/advanced-java/0-1/Week-2/2.10"}}');var i=a(74848),t=a(28453);const l={sidebar_position:9},r="Lamdas & Streams",o={},c=[{value:"Introduction to Lambda Expressions",id:"introduction-to-lambda-expressions",level:2},{value:"What is a Lambda Expression?",id:"what-is-a-lambda-expression",level:3},{value:"Creating and Using a Functional Interface",id:"creating-and-using-a-functional-interface",level:2},{value:"Example: Functional Interface",id:"example-functional-interface",level:3},{value:"Implementing the Interface",id:"implementing-the-interface",level:3},{value:"Creating an Instance of the Interface",id:"creating-an-instance-of-the-interface",level:3},{value:"Using an Anonymous Class (Tedious Way)",id:"using-an-anonymous-class-tedious-way",level:3},{value:"Why Lambdas?",id:"why-lambdas",level:3},{value:"code",id:"code",level:3},{value:"Understanding Functional Interfaces and Lambda Expressions in Java 8",id:"understanding-functional-interfaces-and-lambda-expressions-in-java-8",level:2},{value:"How Lambda Works:",id:"how-lambda-works",level:3},{value:"Explanation:",id:"explanation",level:3},{value:"code",id:"code-1",level:3},{value:"What is a Stream in Java?",id:"what-is-a-stream-in-java",level:2},{value:"Why Streams?",id:"why-streams",level:2},{value:"final code",id:"final-code",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"lamdas--streams",children:"Lamdas & Streams"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-lambda-expressions",children:"Introduction to Lambda Expressions"}),"\n",(0,i.jsx)(e.h3,{id:"what-is-a-lambda-expression",children:"What is a Lambda Expression?"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Lambda is a short and concise way to represent a method using an anonymous function."}),"\n",(0,i.jsx)(e.li,{children:"Lambdas are typically used to implement functional interfaces."}),"\n",(0,i.jsx)(e.li,{children:"A functional interface is an interface that contains only one abstract method."}),"\n",(0,i.jsx)(e.li,{children:"Functional interfaces were introduced in Java 8 to support Lambda expressions."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"creating-and-using-a-functional-interface",children:"Creating and Using a Functional Interface"}),"\n",(0,i.jsx)(e.h3,{id:"example-functional-interface",children:"Example: Functional Interface"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Let's define a functional interface:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"interface Walkable {\n    int walk(int steps);\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"implementing-the-interface",children:"Implementing the Interface"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"You can implement this interface using a class:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'class WalkFast implements Walkable {\n    @Override\n    public int walk(int steps) {\n        System.out.println("Walking fast " + steps + " steps");\n        return 2 * steps;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"creating-an-instance-of-the-interface",children:"Creating an Instance of the Interface"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Using the class implementation:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Walkable obj = new WalkFast();\nint result = obj.walk(4); // Output: Walking fast 4 steps\n"})}),"\n",(0,i.jsx)(e.h3,{id:"using-an-anonymous-class-tedious-way",children:"Using an Anonymous Class (Tedious Way)"}),"\n",(0,i.jsx)(e.p,{children:"You can also use an anonymous class to implement the interface:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Walkable obj = new Walkable() {\n    @Override\n    public int walk(int steps) {\n        return steps * 2;\n    }\n};\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"However, this approach is lengthy and less readable."}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"why-lambdas",children:"Why Lambdas?"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Problem with Traditional Approach","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Creating multiple classes or anonymous classes for small functionalities is verbose."}),"\n",(0,i.jsx)(e.li,{children:"In real-world applications, often you only need a one-time use of an interface implementation."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Solution: Use Lambda Expressions","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Lambdas simplify the creation of interface implementations."}),"\n",(0,i.jsx)(e.li,{children:"We'll explore how to rewrite the above examples using Lambda expressions."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"code",children:"code"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Main {\n    public static void main(String[] args) {\n        Walkable obj = new WalkFast();\n        obj.walk(4);\n    }\n}\n\ninterface Walkable{\n    int walk(int steps);\n}\n\nclass WalkFast implements Walkable {\n\n    @Override\n    public int walk(int steps) {\n        System.out.println("Walking fast "+steps+" steps.");\n        return 2*steps;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"understanding-functional-interfaces-and-lambda-expressions-in-java-8",children:"Understanding Functional Interfaces and Lambda Expressions in Java 8"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Java developers identified a common use case:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"When interfaces have only one method, it is often unnecessary to create separate class implementations or anonymous classes."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Older Way of Implementing Interfaces:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Define a class implementing the interface."}),"\n",(0,i.jsx)(e.li,{children:"Override the method(s) of the interface."}),"\n",(0,i.jsx)(e.li,{children:"Create an object using new keyword."}),"\n",(0,i.jsx)(e.li,{children:"This is useful when interfaces have multiple methods."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Newer Way using Lambda Expressions:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"If an interface has only one abstract method, it's called a functional interface."}),"\n",(0,i.jsx)(e.li,{children:"You can annotate it with @FunctionalInterface (optional but good practice)."}),"\n",(0,i.jsx)(e.li,{children:"This enables a more concise syntax using Lambda expressions."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"how-lambda-works",children:"How Lambda Works:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Instead of:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Walkable object = new Walkable() {\n    @Override\n    public int walk(int steps) {\n        return 2 * steps;\n    }\n};\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"You can write:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Walkable object = (int steps) -> {\n    return 2 * steps;\n};\n"})}),"\n",(0,i.jsx)(e.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["No need to use ",(0,i.jsx)(e.code,{children:"new"})," keyword."]}),"\n",(0,i.jsxs)(e.li,{children:["No need to mention method name (",(0,i.jsx)(e.code,{children:"walk"}),"), as compiler already knows."]}),"\n",(0,i.jsx)(e.li,{children:"You only define parameter(s) and the method body."}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"code-1",children:"code"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public class Main {\n    public static void main(String[] args) {\n        // older way\n//        Walkable obj = new WalkFast();\n//        obj.walk(4);\n\n//        Walkable obj = new Walkable() {\n//            @Override\n//            public int walk(int steps) {\n//                return 0;\n//            }\n//        };\n\n        Walkable obj = (steps, isEnabled) -> {\n            System.out.println("Walking fast "+steps+" steps.");\n            return 2*steps;\n        };\n\n        Walkable obj2 = (steps, isEnabled) -> 2*steps;\n        obj.walk(5, true);\n\n    }\n}\n\n\n@FunctionalInterface\ninterface Walkable{\n    int walk(int steps, boolean isEnabled);\n}\n\n//class WalkFast implements Walkable {\n//\n//    @Override\n//    public int walk(int steps) {\n//        System.out.println("Walking fast "+steps+" steps.");\n//        return 2*steps;\n//    }\n//}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"what-is-a-stream-in-java",children:"What is a Stream in Java?"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"A Stream is a sequence of elements (like a list) that supports various operations to perform computation in a declarative way (what to do, not how to do it)."}),"\n",(0,i.jsx)(e.li,{children:"Think of a stream like flowing water \u2014 once it flows past a point, it cannot go back. Similarly, in Java, once a stream is consumed (used), it cannot be reused."}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"why-streams",children:"Why Streams?"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Helps process collections (like ",(0,i.jsx)(e.code,{children:"List"}),", ",(0,i.jsx)(e.code,{children:"Set"}),") in a functional style"]}),"\n",(0,i.jsxs)(e.li,{children:["Supports method chaining (like ",(0,i.jsx)(e.code,{children:".filter().map().sorted()"}),")"]}),"\n",(0,i.jsx)(e.li,{children:"Helps write clean and concise code"}),"\n",(0,i.jsx)(e.li,{children:"Great for memory management, since streams can be closed and reused efficiently"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"final-code",children:"final code"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'import java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> fruits = List.of("Banana", "Apple" , "Kiwi");\n\n        Stream<String> stream = fruits.stream();\n\n//        stream.forEach((fruit) -> {\n//            System.out.println(fruit);\n//        });\n        \n//        stream\n//                .filter(fruit -> fruit.length() < 5)\n//                .sorted()\n////                .map(fruit -> fruit.length())\n////                .map(fruitLength -> 2*fruitLength)\n//                .forEach(fruit -> System.out.println(fruit));\n\n//        List<Integer> fruitsList = fruits\n//                                        .stream()\n//                                        .map(fruit -> fruit.length())\n//                                        .collect(Collectors.toList());\n//\n//        System.out.println(fruitsList);\n\n//        Set<Integer> fruitsList = fruits\n//                .stream()\n//                .map(fruit -> fruit.length())\n//                .collect(Collectors.toSet());\n//\n//        System.out.println(fruitsList);\n\n        Map<String, Integer> fruitsList = fruits\n                .stream()\n//                .map(fruit -> fruit.length())\n                .collect(Collectors.toMap(\n                        key -> key,\n                        fruit -> fruit.length()\n                ));\n\n        System.out.println(fruitsList);\n    }\n}\n'})})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},28453:(n,e,a)=>{a.d(e,{R:()=>l,x:()=>r});var s=a(96540);const i={},t=s.createContext(i);function l(n){const e=s.useContext(t);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:l(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);